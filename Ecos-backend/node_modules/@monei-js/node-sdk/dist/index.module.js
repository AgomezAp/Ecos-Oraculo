import globalAxios from 'axios';
import * as crypto from 'crypto';

function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}

var name = "@monei-js/node-sdk";
var description = "Node.js SDK for MONEI Digital Payment Gateway";
var version = "1.7.10";
var homepage = "https://monei.com";
var author = "MONEI <support@monei.com> (https://monei.com)";
var type = "module";
var license = "MIT";
var contributors = [
	"Dmitriy Nevzorov <dn@monei.com>"
];
var repository = {
	type: "git",
	url: "https://github.com/MONEI/monei-node-sdk"
};
var keywords = [
	"monei",
	"payment gateway",
	"payment processing",
	"credit cards",
	"api"
];
var files = [
	"dist",
	"LICENSE",
	"README.md"
];
var source = "./index.ts";
var main = "./dist/index.cjs";
var module = "./dist/index.module.js";
var types = "./dist/index.d.ts";
var exports = {
	".": {
		types: "./dist/index.d.ts",
		require: "./dist/index.cjs",
		"import": "./dist/index.module.js"
	}
};
var publishConfig = {
	access: "public",
	registry: "https://registry.npmjs.org/"
};
var scripts = {
	generate: "openapi-generator-cli generate --generator-key typescript-axios",
	"generate:local": "openapi-generator-cli generate --generator-key typescript-axios-local",
	compile: "microbundle -f modern,cjs --target node --strict --name index --tsconfig tsconfig.build.json",
	dev: "microbundle watch -f modern,cjs --target node --strict --name index --tsconfig tsconfig.build.json",
	build: "run-s generate replace format compile",
	"build:local": "run-s generate:local replace format compile",
	replace: "node scripts/replace.js",
	release: "release-it",
	prepack: "yarn build",
	test: "vitest run",
	"test:watch": "vitest",
	"test:coverage": "vitest run --coverage",
	commitlint: "commitlint --edit",
	typecheck: "tsc --noEmit",
	"lint-staged": "lint-staged",
	format: "prettier --write \"**/*.ts\"",
	lint: "eslint .",
	"lint:fix": "eslint . --fix",
	prepare: "husky"
};
var devDependencies = {
	"@commitlint/cli": "^19.8.0",
	"@commitlint/config-conventional": "^19.8.0",
	"@eslint/js": "^9.22.0",
	"@openapitools/openapi-generator-cli": "^2.17.0",
	"@release-it/conventional-changelog": "^10.0.0",
	"@types/node": "^22.13.10",
	"@vitest/coverage-v8": "^3.0.8",
	"axios-mock-adapter": "^2.1.0",
	eslint: "^9.22.0",
	husky: "^9.1.7",
	"lint-staged": "^15.4.3",
	microbundle: "^0.15.1",
	"npm-run-all": "^4.1.5",
	prettier: "^3.5.3",
	"release-it": "^18.1.2",
	"replace-in-file": "^8.3.0",
	typescript: "^5.8.2",
	"typescript-eslint": "^8.26.1",
	vitest: "^3.0.8"
};
var dependencies = {
	axios: "^1.8.2"
};
var packageManager = "yarn@4.7.0";
var pkg = {
	name: name,
	description: description,
	version: version,
	homepage: homepage,
	author: author,
	type: type,
	license: license,
	contributors: contributors,
	repository: repository,
	keywords: keywords,
	files: files,
	source: source,
	main: main,
	module: module,
	types: types,
	exports: exports,
	publishConfig: publishConfig,
	scripts: scripts,
	"lint-staged": {
	"*.ts": [
		"prettier --write",
		"eslint --quiet --fix"
	]
},
	devDependencies: devDependencies,
	dependencies: dependencies,
	packageManager: packageManager
};

/* tslint:disable */
const BASE_PATH = 'https://api.monei.com/v1'.replace(/\/+$/, '');
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
  constructor(configuration, basePath = BASE_PATH, axios = globalAxios) {
    this.basePath = void 0;
    this.axios = void 0;
    this.configuration = void 0;
    this.basePath = basePath;
    this.axios = axios;
    if (configuration) {
      var _configuration$basePa;
      this.configuration = configuration;
      this.basePath = (_configuration$basePa = configuration.basePath) != null ? _configuration$basePa : basePath;
    }
  }
}
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = void 0;
    this.field = field;
    this.name = 'RequiredError';
  }
}
/**
 *
 * @export
 */
const operationServerMap = {};

/**
 *
 * @export
 */
const DUMMY_BASE_URL = 'https://example.com';
/**
 *
 * @throws {RequiredError}
 * @export
 */
const assertParamExists = function assertParamExists(functionName, paramName, paramValue) {
  if (paramValue === null || paramValue === undefined) {
    throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
  }
};
/**
 *
 * @export
 */
const setApiKeyToObject = async function setApiKeyToObject(object, keyParamName, configuration) {
  if (configuration && configuration.apiKey) {
    const localVarApiKeyValue = typeof configuration.apiKey === 'function' ? await configuration.apiKey(keyParamName) : await configuration.apiKey;
    object[keyParamName] = localVarApiKeyValue;
  }
};
function setFlattenedQueryParams(urlSearchParams, parameter, key = '') {
  if (parameter == null) return;
  if (typeof parameter === 'object') {
    if (Array.isArray(parameter)) {
      parameter.forEach(item => setFlattenedQueryParams(urlSearchParams, item, key));
    } else {
      Object.keys(parameter).forEach(currentKey => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`));
    }
  } else {
    if (urlSearchParams.has(key)) {
      urlSearchParams.append(key, parameter);
    } else {
      urlSearchParams.set(key, parameter);
    }
  }
}
/**
 *
 * @export
 */
const setSearchParams = function setSearchParams(url, ...objects) {
  const searchParams = new URLSearchParams(url.search);
  setFlattenedQueryParams(searchParams, objects);
  url.search = searchParams.toString();
};
/**
 *
 * @export
 */
const serializeDataIfNeeded = function serializeDataIfNeeded(value, requestOptions, configuration) {
  const nonString = typeof value !== 'string';
  const needsSerialization = nonString && configuration && configuration.isJsonMime ? configuration.isJsonMime(requestOptions.headers['Content-Type']) : nonString;
  return needsSerialization ? JSON.stringify(value !== undefined ? value : {}) : value || '';
};
/**
 *
 * @export
 */
const toPathString = function toPathString(url) {
  return url.pathname + url.search + url.hash;
};
/**
 *
 * @export
 */
const createRequestFunction = function createRequestFunction(axiosArgs, globalAxios, BASE_PATH, configuration) {
  return (axios = globalAxios, basePath = BASE_PATH) => {
    var _configuration$basePa;
    const axiosRequestArgs = _extends({}, axiosArgs.options, {
      url: (axios.defaults.baseURL ? '' : (_configuration$basePa = configuration == null ? void 0 : configuration.basePath) != null ? _configuration$basePa : basePath) + axiosArgs.url
    });
    return axios.request(axiosRequestArgs);
  };
};

/**
 * ApplePayDomainApi - axios parameter creator
 * @export
 */
const ApplePayDomainApiAxiosParamCreator = function ApplePayDomainApiAxiosParamCreator(configuration) {
  return {
    /**
     * Registers a domain with Apple Pay.  This endpoint allows you to register your website domain with Apple Pay, which is required before you can accept Apple Pay payments on your website. The domain must be accessible via HTTPS and have a valid SSL certificate.  Before registering, you must download this [domain association file](https://assets.monei.com/apple-pay/apple-developer-merchantid-domain-association/) and host it at `/.well-known/apple-developer-merchantid-domain-association` on your site.  For example, if you\'re registering `example.com`, make that file available at `https://example.com/.well-known/apple-developer-merchantid-domain-association`.  After registration, Apple will verify your domain. Once verified, you can display Apple Pay buttons and process Apple Pay payments on your website.
     * @summary Register Domain
     * @param {RegisterApplePayDomainRequest} registerApplePayDomainRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register: async (registerApplePayDomainRequest, options = {}) => {
      // verify required parameter 'registerApplePayDomainRequest' is not null or undefined
      assertParamExists('register', 'registerApplePayDomainRequest', registerApplePayDomainRequest);
      const localVarPath = `/apple-pay/domains`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'POST'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      localVarHeaderParameter['Content-Type'] = 'application/json';
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      localVarRequestOptions.data = serializeDataIfNeeded(registerApplePayDomainRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
/**
 * ApplePayDomainApi - functional programming interface
 * @export
 */
const ApplePayDomainApiFp = function ApplePayDomainApiFp(configuration) {
  const localVarAxiosParamCreator = ApplePayDomainApiAxiosParamCreator(configuration);
  return {
    /**
     * Registers a domain with Apple Pay.  This endpoint allows you to register your website domain with Apple Pay, which is required before you can accept Apple Pay payments on your website. The domain must be accessible via HTTPS and have a valid SSL certificate.  Before registering, you must download this [domain association file](https://assets.monei.com/apple-pay/apple-developer-merchantid-domain-association/) and host it at `/.well-known/apple-developer-merchantid-domain-association` on your site.  For example, if you\'re registering `example.com`, make that file available at `https://example.com/.well-known/apple-developer-merchantid-domain-association`.  After registration, Apple will verify your domain. Once verified, you can display Apple Pay buttons and process Apple Pay payments on your website.
     * @summary Register Domain
     * @param {RegisterApplePayDomainRequest} registerApplePayDomainRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async register(registerApplePayDomainRequest, options) {
      var _configuration$server, _operationServerMap$A;
      const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerApplePayDomainRequest, options);
      const localVarOperationServerIndex = (_configuration$server = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server : 0;
      const localVarOperationServerBasePath = (_operationServerMap$A = operationServerMap['ApplePayDomainApi.register']) == null || (_operationServerMap$A = _operationServerMap$A[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$A.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    }
  };
};
/**
 * ApplePayDomainApi - factory interface
 * @export
 */
const ApplePayDomainApiFactory = function ApplePayDomainApiFactory(configuration, basePath, axios) {
  const localVarFp = ApplePayDomainApiFp(configuration);
  return {
    /**
     * Registers a domain with Apple Pay.  This endpoint allows you to register your website domain with Apple Pay, which is required before you can accept Apple Pay payments on your website. The domain must be accessible via HTTPS and have a valid SSL certificate.  Before registering, you must download this [domain association file](https://assets.monei.com/apple-pay/apple-developer-merchantid-domain-association/) and host it at `/.well-known/apple-developer-merchantid-domain-association` on your site.  For example, if you\'re registering `example.com`, make that file available at `https://example.com/.well-known/apple-developer-merchantid-domain-association`.  After registration, Apple will verify your domain. Once verified, you can display Apple Pay buttons and process Apple Pay payments on your website.
     * @summary Register Domain
     * @param {RegisterApplePayDomainRequest} registerApplePayDomainRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register(registerApplePayDomainRequest, options) {
      return localVarFp.register(registerApplePayDomainRequest, options).then(request => request(axios, basePath));
    }
  };
};
/**
 * ApplePayDomainApi - object-oriented interface
 * @export
 * @class ApplePayDomainApi
 * @extends {BaseAPI}
 */
class ApplePayDomainApi extends BaseAPI {
  /**
   * Registers a domain with Apple Pay.  This endpoint allows you to register your website domain with Apple Pay, which is required before you can accept Apple Pay payments on your website. The domain must be accessible via HTTPS and have a valid SSL certificate.  Before registering, you must download this [domain association file](https://assets.monei.com/apple-pay/apple-developer-merchantid-domain-association/) and host it at `/.well-known/apple-developer-merchantid-domain-association` on your site.  For example, if you\'re registering `example.com`, make that file available at `https://example.com/.well-known/apple-developer-merchantid-domain-association`.  After registration, Apple will verify your domain. Once verified, you can display Apple Pay buttons and process Apple Pay payments on your website.
   * @summary Register Domain
   * @param {RegisterApplePayDomainRequest} registerApplePayDomainRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplePayDomainApi
   */
  register(registerApplePayDomainRequest, options) {
    return ApplePayDomainApiFp(this.configuration).register(registerApplePayDomainRequest, options).then(request => request(this.axios, this.basePath));
  }
}

/**
 * BizumApi - axios parameter creator
 * @export
 */
const BizumApiAxiosParamCreator = function BizumApiAxiosParamCreator(configuration) {
  return {
    /**
     * Validates if a phone number is registered with Bizum.  Use this endpoint to check if a customer\'s phone number can be used for Bizum payments before attempting to process a payment. This helps provide a better user experience by preventing failed payment attempts for non-registered numbers.  The response will indicate whether the phone number is valid for Bizum payments.
     * @summary Validate Phone
     * @param {ValidateBizumPhoneRequest} validateBizumPhoneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validatePhone: async (validateBizumPhoneRequest, options = {}) => {
      // verify required parameter 'validateBizumPhoneRequest' is not null or undefined
      assertParamExists('validatePhone', 'validateBizumPhoneRequest', validateBizumPhoneRequest);
      const localVarPath = `/bizum/validate-phone`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'POST'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      localVarHeaderParameter['Content-Type'] = 'application/json';
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      localVarRequestOptions.data = serializeDataIfNeeded(validateBizumPhoneRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
/**
 * BizumApi - functional programming interface
 * @export
 */
const BizumApiFp = function BizumApiFp(configuration) {
  const localVarAxiosParamCreator = BizumApiAxiosParamCreator(configuration);
  return {
    /**
     * Validates if a phone number is registered with Bizum.  Use this endpoint to check if a customer\'s phone number can be used for Bizum payments before attempting to process a payment. This helps provide a better user experience by preventing failed payment attempts for non-registered numbers.  The response will indicate whether the phone number is valid for Bizum payments.
     * @summary Validate Phone
     * @param {ValidateBizumPhoneRequest} validateBizumPhoneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validatePhone(validateBizumPhoneRequest, options) {
      var _configuration$server, _operationServerMap$B;
      const localVarAxiosArgs = await localVarAxiosParamCreator.validatePhone(validateBizumPhoneRequest, options);
      const localVarOperationServerIndex = (_configuration$server = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server : 0;
      const localVarOperationServerBasePath = (_operationServerMap$B = operationServerMap['BizumApi.validatePhone']) == null || (_operationServerMap$B = _operationServerMap$B[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$B.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    }
  };
};
/**
 * BizumApi - factory interface
 * @export
 */
const BizumApiFactory = function BizumApiFactory(configuration, basePath, axios) {
  const localVarFp = BizumApiFp(configuration);
  return {
    /**
     * Validates if a phone number is registered with Bizum.  Use this endpoint to check if a customer\'s phone number can be used for Bizum payments before attempting to process a payment. This helps provide a better user experience by preventing failed payment attempts for non-registered numbers.  The response will indicate whether the phone number is valid for Bizum payments.
     * @summary Validate Phone
     * @param {ValidateBizumPhoneRequest} validateBizumPhoneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validatePhone(validateBizumPhoneRequest, options) {
      return localVarFp.validatePhone(validateBizumPhoneRequest, options).then(request => request(axios, basePath));
    }
  };
};
/**
 * BizumApi - object-oriented interface
 * @export
 * @class BizumApi
 * @extends {BaseAPI}
 */
class BizumApi extends BaseAPI {
  /**
   * Validates if a phone number is registered with Bizum.  Use this endpoint to check if a customer\'s phone number can be used for Bizum payments before attempting to process a payment. This helps provide a better user experience by preventing failed payment attempts for non-registered numbers.  The response will indicate whether the phone number is valid for Bizum payments.
   * @summary Validate Phone
   * @param {ValidateBizumPhoneRequest} validateBizumPhoneRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BizumApi
   */
  validatePhone(validateBizumPhoneRequest, options) {
    return BizumApiFp(this.configuration).validatePhone(validateBizumPhoneRequest, options).then(request => request(this.axios, this.basePath));
  }
}

/**
 * PaymentMethodsApi - axios parameter creator
 * @export
 */
const PaymentMethodsApiAxiosParamCreator = function PaymentMethodsApiAxiosParamCreator(configuration) {
  return {
    /**
     * Retrieve available payment methods for an account or a specific payment.  You can provide either an `accountId` or a `paymentId` as a query parameter to get the available payment methods.  When providing a `paymentId`, the response will include additional payment-specific information such as amount and currency. This is useful when you want to show payment options that are specifically available for a particular transaction.  When providing an `accountId`, the response will include all payment methods available for that account based on the merchant\'s configuration and supported payment methods.
     * @summary Get Payment Methods
     * @param {string} [accountId] The ID of the account to get payment methods for
     * @param {string} [paymentId] The ID of the payment to get payment methods for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get: async (accountId, paymentId, options = {}) => {
      const localVarPath = `/payment-methods`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'GET'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      if (accountId !== undefined) {
        localVarQueryParameter['accountId'] = accountId;
      }
      if (paymentId !== undefined) {
        localVarQueryParameter['paymentId'] = paymentId;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
/**
 * PaymentMethodsApi - functional programming interface
 * @export
 */
const PaymentMethodsApiFp = function PaymentMethodsApiFp(configuration) {
  const localVarAxiosParamCreator = PaymentMethodsApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieve available payment methods for an account or a specific payment.  You can provide either an `accountId` or a `paymentId` as a query parameter to get the available payment methods.  When providing a `paymentId`, the response will include additional payment-specific information such as amount and currency. This is useful when you want to show payment options that are specifically available for a particular transaction.  When providing an `accountId`, the response will include all payment methods available for that account based on the merchant\'s configuration and supported payment methods.
     * @summary Get Payment Methods
     * @param {string} [accountId] The ID of the account to get payment methods for
     * @param {string} [paymentId] The ID of the payment to get payment methods for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async get(accountId, paymentId, options) {
      var _configuration$server, _operationServerMap$P;
      const localVarAxiosArgs = await localVarAxiosParamCreator.get(accountId, paymentId, options);
      const localVarOperationServerIndex = (_configuration$server = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server : 0;
      const localVarOperationServerBasePath = (_operationServerMap$P = operationServerMap['PaymentMethodsApi.get']) == null || (_operationServerMap$P = _operationServerMap$P[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$P.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    }
  };
};
/**
 * PaymentMethodsApi - factory interface
 * @export
 */
const PaymentMethodsApiFactory = function PaymentMethodsApiFactory(configuration, basePath, axios) {
  const localVarFp = PaymentMethodsApiFp(configuration);
  return {
    /**
     * Retrieve available payment methods for an account or a specific payment.  You can provide either an `accountId` or a `paymentId` as a query parameter to get the available payment methods.  When providing a `paymentId`, the response will include additional payment-specific information such as amount and currency. This is useful when you want to show payment options that are specifically available for a particular transaction.  When providing an `accountId`, the response will include all payment methods available for that account based on the merchant\'s configuration and supported payment methods.
     * @summary Get Payment Methods
     * @param {string} [accountId] The ID of the account to get payment methods for
     * @param {string} [paymentId] The ID of the payment to get payment methods for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get(accountId, paymentId, options) {
      return localVarFp.get(accountId, paymentId, options).then(request => request(axios, basePath));
    }
  };
};
/**
 * PaymentMethodsApi - object-oriented interface
 * @export
 * @class PaymentMethodsApi
 * @extends {BaseAPI}
 */
class PaymentMethodsApi extends BaseAPI {
  /**
   * Retrieve available payment methods for an account or a specific payment.  You can provide either an `accountId` or a `paymentId` as a query parameter to get the available payment methods.  When providing a `paymentId`, the response will include additional payment-specific information such as amount and currency. This is useful when you want to show payment options that are specifically available for a particular transaction.  When providing an `accountId`, the response will include all payment methods available for that account based on the merchant\'s configuration and supported payment methods.
   * @summary Get Payment Methods
   * @param {string} [accountId] The ID of the account to get payment methods for
   * @param {string} [paymentId] The ID of the payment to get payment methods for
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentMethodsApi
   */
  get(accountId, paymentId, options) {
    return PaymentMethodsApiFp(this.configuration).get(accountId, paymentId, options).then(request => request(this.axios, this.basePath));
  }
}

/**
 * PaymentsApi - axios parameter creator
 * @export
 */
const PaymentsApiAxiosParamCreator = function PaymentsApiAxiosParamCreator(configuration) {
  return {
    /**
     * Releases reserved funds from a previously authorized payment. This endpoint can only be used with payments in `AUTHORIZED` status.  This operation is part of the two-step authorization flow:  1. **Authorize**: Create a payment with `transactionType: AUTH` to reserve funds 2. **Cancel**: Release the reserved funds if you decide not to capture the payment  Cancellation makes the reserved funds available to the customer again and prevents you from being able to capture those funds in the future. Once cancelled, an authorization cannot be reactivated.
     * @summary Cancel Payment
     * @param {string} id The payment ID
     * @param {CancelPaymentRequest} [cancelPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancel: async (id, cancelPaymentRequest, options = {}) => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('cancel', 'id', id);
      const localVarPath = `/payments/{id}/cancel`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'POST'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      localVarHeaderParameter['Content-Type'] = 'application/json';
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      localVarRequestOptions.data = serializeDataIfNeeded(cancelPaymentRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Captures funds from a previously authorized payment. This endpoint can only be used with payments in `AUTHORIZED` status.  This operation completes the two-step authorization flow:  1. **Authorize**: Create a payment with `transactionType: AUTH` to reserve funds 2. **Capture**: Transfer the reserved funds to your account when ready to fulfill the order  **Important**: Authorized payments expire after exactly seven days. After expiration, they will be marked as `EXPIRED` and can no longer be captured. Be sure to capture funds within this timeframe or communicate with your customer about a new payment.
     * @summary Capture Payment
     * @param {string} id The payment ID
     * @param {CapturePaymentRequest} [capturePaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    capture: async (id, capturePaymentRequest, options = {}) => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('capture', 'id', id);
      const localVarPath = `/payments/{id}/capture`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'POST'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      localVarHeaderParameter['Content-Type'] = 'application/json';
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      localVarRequestOptions.data = serializeDataIfNeeded(capturePaymentRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Confirms a payment that was created without payment details. This endpoint can only be used with payments in `PENDING` status.  The two-step payment flow:  1. **Create**: First, create a payment without payment details (status: `PENDING`) 2. **Confirm**: Then provide payment details to complete the transaction  When confirming a payment, you can use:  - A newly generated `paymentToken` from [monei.js Components](https://docs.monei.com/monei-js/overview/) - A permanent `paymentToken` from a previous payment (generated with `generatePaymentToken: true`)  Using permanent payment tokens enables one-click checkout experiences for returning customers without requiring them to re-enter their payment information.  You can provide additional customer information during confirmation, which will override any corresponding information originally passed in the payment creation request.
     * @summary Confirm Payment
     * @param {string} id The payment ID
     * @param {ConfirmPaymentRequest} [confirmPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirm: async (id, confirmPaymentRequest, options = {}) => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('confirm', 'id', id);
      const localVarPath = `/payments/{id}/confirm`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'POST'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      localVarHeaderParameter['Content-Type'] = 'application/json';
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      localVarRequestOptions.data = serializeDataIfNeeded(confirmPaymentRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new payment with the specified parameters.  You can create a payment in two ways:  1. **Immediate processing**: Provide a `paymentToken` or `paymentMethod` - The payment will be processed instantly 2. **Deferred processing**: Create without payment details - The payment remains in `PENDING` status until you    confirm it later using the [confirm endpoint](https://docs.monei.com/apis/rest/payments-confirm/)  When creating a payment without payment details, you can redirect customers to the hosted payment page where they can select their preferred payment method and complete the transaction.  For immediate processing, use one of these token options:  - A temporary `paymentToken` generated on the frontend using [monei.js Components](https://docs.monei.com/monei-js/overview/) - A permanent `paymentToken` from a previous successful payment (when `generatePaymentToken: true` was included)  Permanent tokens enable one-click checkout experiences for returning customers by allowing you to securely store and reuse payment details without requiring customers to re-enter their information.
     * @summary Create Payment
     * @param {CreatePaymentRequest} createPaymentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (createPaymentRequest, options = {}) => {
      // verify required parameter 'createPaymentRequest' is not null or undefined
      assertParamExists('create', 'createPaymentRequest', createPaymentRequest);
      const localVarPath = `/payments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'POST'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      localVarHeaderParameter['Content-Type'] = 'application/json';
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      localVarRequestOptions.data = serializeDataIfNeeded(createPaymentRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieves the complete details of an existing payment by its unique ID.  This endpoint returns all available information about the payment, including its current status, amount, customer details, timestamps, and transaction history. Use this to check the status of a payment, verify payment details, or retrieve information for your records.  Supply the unique payment ID that was returned from your previous request.
     * @summary Get Payment
     * @param {string} id The payment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get: async (id, options = {}) => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('get', 'id', id);
      const localVarPath = `/payments/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'GET'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a subsequent charge using the payment details from a previous transaction.  This endpoint enables recurring billing and subscription payments by:  - Using the same payment method as the original payment - Charging the customer without requiring them to re-enter payment details - Supporting variable or fixed amounts (defaults to the original payment amount if not specified)  **Prerequisites:**  1. The initial payment must be created with the `sequence` parameter 2. The initial payment will return a `sequenceId` in the response 3. This `sequenceId` must be provided in the URL path when making subsequent recurring charges  Ideal for subscription services, membership renewals, and installment payments.  **Need more advanced subscription management?** For comprehensive subscription management with features like billing cycles, trial periods, and automatic recurring billing, consider using the [Subscriptions API](https://docs.monei.com/apis/rest/subscriptions/) instead. It provides a complete solution for creating and managing subscription-based services.
     * @summary Recurring Payment
     * @param {string} sequenceId The sequence ID
     * @param {RecurringPaymentRequest} [recurringPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recurring: async (sequenceId, recurringPaymentRequest, options = {}) => {
      // verify required parameter 'sequenceId' is not null or undefined
      assertParamExists('recurring', 'sequenceId', sequenceId);
      const localVarPath = `/payments/{sequenceId}/recurring`.replace(`{${'sequenceId'}}`, encodeURIComponent(String(sequenceId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'POST'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      localVarHeaderParameter['Content-Type'] = 'application/json';
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      localVarRequestOptions.data = serializeDataIfNeeded(recurringPaymentRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns funds from a completed payment back to the customer\'s original payment method.  **Refund options:**  - **Full refund**: Return the entire payment amount - **Partial refund**: Specify an amount less than the original payment - **Multiple partial refunds**: Issue several partial refunds until the total payment amount is reached  **Limitations:**  - You can only refund payments that have been successfully processed - A payment can only be refunded up to its original amount - Once fully refunded, a payment cannot be refunded again - Attempting to refund more than the remaining available amount will result in an error
     * @summary Refund Payment
     * @param {string} id The payment ID
     * @param {RefundPaymentRequest} [refundPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refund: async (id, refundPaymentRequest, options = {}) => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('refund', 'id', id);
      const localVarPath = `/payments/{id}/refund`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'POST'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      localVarHeaderParameter['Content-Type'] = 'application/json';
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      localVarRequestOptions.data = serializeDataIfNeeded(refundPaymentRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Sends a payment link to the customer through their preferred communication channel.  **This API can only be used for payments with the following status:**  - Pending  **Delivery channels are automatically selected based on available customer information:**  - If customer email is available: Link is sent via email - If customer phone is available: Link is sent via WhatsApp - If WhatsApp delivery fails: Link is sent via SMS as a fallback  The payment link allows customers to complete the payment at their convenience using their preferred payment method on the secure MONEI payment page. If no customer contact information is provided, the system will use the details stored in the payment record.
     * @summary Send Payment Link
     * @param {string} id The payment ID
     * @param {SendPaymentLinkRequest} [sendPaymentLinkRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendLink: async (id, sendPaymentLinkRequest, options = {}) => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('sendLink', 'id', id);
      const localVarPath = `/payments/{id}/link`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'POST'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      localVarHeaderParameter['Content-Type'] = 'application/json';
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      localVarRequestOptions.data = serializeDataIfNeeded(sendPaymentLinkRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Sends a payment receipt to the customer through their preferred communication channel.  **This API can only be used for payments with the following status:**  - Succeeded  **Delivery channels are automatically selected based on available customer information:**  - If customer email is available: Receipt is sent via email - If customer phone is available: Receipt is sent via WhatsApp - If WhatsApp delivery fails: Receipt is sent via SMS as a fallback  The receipt includes payment details such as amount, date, transaction ID, and merchant information, providing customers with a record of their successful transaction. If no customer contact information is provided, the system will use the details stored in the payment record.
     * @summary Send Payment Receipt
     * @param {string} id The payment ID
     * @param {SendPaymentReceiptRequest} [sendPaymentReceiptRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendReceipt: async (id, sendPaymentReceiptRequest, options = {}) => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('sendReceipt', 'id', id);
      const localVarPath = `/payments/{id}/receipt`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'POST'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      localVarHeaderParameter['Content-Type'] = 'application/json';
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      localVarRequestOptions.data = serializeDataIfNeeded(sendPaymentReceiptRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Sends a direct payment request to the customer\'s phone with smart channel selection.  **Smart delivery logic based on customer phone capabilities:**  - If the phone number is registered with Bizum and that payment method is available:   The customer receives a push notification in their banking app to instantly approve the payment - If Bizum is not available or the phone is not registered with Bizum:   The customer receives a payment link via WhatsApp to complete the payment  This endpoint provides a streamlined payment experience, especially for Spanish customers with Bizum integration, enabling quick and convenient mobile payments.
     * @summary Send Payment Request
     * @param {string} id The payment ID
     * @param {SendPaymentRequestRequest} sendPaymentRequestRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendRequest: async (id, sendPaymentRequestRequest, options = {}) => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('sendRequest', 'id', id);
      // verify required parameter 'sendPaymentRequestRequest' is not null or undefined
      assertParamExists('sendRequest', 'sendPaymentRequestRequest', sendPaymentRequestRequest);
      const localVarPath = `/payments/{id}/rtp`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'POST'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      localVarHeaderParameter['Content-Type'] = 'application/json';
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      localVarRequestOptions.data = serializeDataIfNeeded(sendPaymentRequestRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
/**
 * PaymentsApi - functional programming interface
 * @export
 */
const PaymentsApiFp = function PaymentsApiFp(configuration) {
  const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration);
  return {
    /**
     * Releases reserved funds from a previously authorized payment. This endpoint can only be used with payments in `AUTHORIZED` status.  This operation is part of the two-step authorization flow:  1. **Authorize**: Create a payment with `transactionType: AUTH` to reserve funds 2. **Cancel**: Release the reserved funds if you decide not to capture the payment  Cancellation makes the reserved funds available to the customer again and prevents you from being able to capture those funds in the future. Once cancelled, an authorization cannot be reactivated.
     * @summary Cancel Payment
     * @param {string} id The payment ID
     * @param {CancelPaymentRequest} [cancelPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancel(id, cancelPaymentRequest, options) {
      var _configuration$server, _operationServerMap$P;
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(id, cancelPaymentRequest, options);
      const localVarOperationServerIndex = (_configuration$server = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server : 0;
      const localVarOperationServerBasePath = (_operationServerMap$P = operationServerMap['PaymentsApi.cancel']) == null || (_operationServerMap$P = _operationServerMap$P[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$P.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Captures funds from a previously authorized payment. This endpoint can only be used with payments in `AUTHORIZED` status.  This operation completes the two-step authorization flow:  1. **Authorize**: Create a payment with `transactionType: AUTH` to reserve funds 2. **Capture**: Transfer the reserved funds to your account when ready to fulfill the order  **Important**: Authorized payments expire after exactly seven days. After expiration, they will be marked as `EXPIRED` and can no longer be captured. Be sure to capture funds within this timeframe or communicate with your customer about a new payment.
     * @summary Capture Payment
     * @param {string} id The payment ID
     * @param {CapturePaymentRequest} [capturePaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async capture(id, capturePaymentRequest, options) {
      var _configuration$server2, _operationServerMap$P2;
      const localVarAxiosArgs = await localVarAxiosParamCreator.capture(id, capturePaymentRequest, options);
      const localVarOperationServerIndex = (_configuration$server2 = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server2 : 0;
      const localVarOperationServerBasePath = (_operationServerMap$P2 = operationServerMap['PaymentsApi.capture']) == null || (_operationServerMap$P2 = _operationServerMap$P2[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$P2.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Confirms a payment that was created without payment details. This endpoint can only be used with payments in `PENDING` status.  The two-step payment flow:  1. **Create**: First, create a payment without payment details (status: `PENDING`) 2. **Confirm**: Then provide payment details to complete the transaction  When confirming a payment, you can use:  - A newly generated `paymentToken` from [monei.js Components](https://docs.monei.com/monei-js/overview/) - A permanent `paymentToken` from a previous payment (generated with `generatePaymentToken: true`)  Using permanent payment tokens enables one-click checkout experiences for returning customers without requiring them to re-enter their payment information.  You can provide additional customer information during confirmation, which will override any corresponding information originally passed in the payment creation request.
     * @summary Confirm Payment
     * @param {string} id The payment ID
     * @param {ConfirmPaymentRequest} [confirmPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async confirm(id, confirmPaymentRequest, options) {
      var _configuration$server3, _operationServerMap$P3;
      const localVarAxiosArgs = await localVarAxiosParamCreator.confirm(id, confirmPaymentRequest, options);
      const localVarOperationServerIndex = (_configuration$server3 = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server3 : 0;
      const localVarOperationServerBasePath = (_operationServerMap$P3 = operationServerMap['PaymentsApi.confirm']) == null || (_operationServerMap$P3 = _operationServerMap$P3[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$P3.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Creates a new payment with the specified parameters.  You can create a payment in two ways:  1. **Immediate processing**: Provide a `paymentToken` or `paymentMethod` - The payment will be processed instantly 2. **Deferred processing**: Create without payment details - The payment remains in `PENDING` status until you    confirm it later using the [confirm endpoint](https://docs.monei.com/apis/rest/payments-confirm/)  When creating a payment without payment details, you can redirect customers to the hosted payment page where they can select their preferred payment method and complete the transaction.  For immediate processing, use one of these token options:  - A temporary `paymentToken` generated on the frontend using [monei.js Components](https://docs.monei.com/monei-js/overview/) - A permanent `paymentToken` from a previous successful payment (when `generatePaymentToken: true` was included)  Permanent tokens enable one-click checkout experiences for returning customers by allowing you to securely store and reuse payment details without requiring customers to re-enter their information.
     * @summary Create Payment
     * @param {CreatePaymentRequest} createPaymentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(createPaymentRequest, options) {
      var _configuration$server4, _operationServerMap$P4;
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(createPaymentRequest, options);
      const localVarOperationServerIndex = (_configuration$server4 = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server4 : 0;
      const localVarOperationServerBasePath = (_operationServerMap$P4 = operationServerMap['PaymentsApi.create']) == null || (_operationServerMap$P4 = _operationServerMap$P4[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$P4.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves the complete details of an existing payment by its unique ID.  This endpoint returns all available information about the payment, including its current status, amount, customer details, timestamps, and transaction history. Use this to check the status of a payment, verify payment details, or retrieve information for your records.  Supply the unique payment ID that was returned from your previous request.
     * @summary Get Payment
     * @param {string} id The payment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async get(id, options) {
      var _configuration$server5, _operationServerMap$P5;
      const localVarAxiosArgs = await localVarAxiosParamCreator.get(id, options);
      const localVarOperationServerIndex = (_configuration$server5 = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server5 : 0;
      const localVarOperationServerBasePath = (_operationServerMap$P5 = operationServerMap['PaymentsApi.get']) == null || (_operationServerMap$P5 = _operationServerMap$P5[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$P5.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Creates a subsequent charge using the payment details from a previous transaction.  This endpoint enables recurring billing and subscription payments by:  - Using the same payment method as the original payment - Charging the customer without requiring them to re-enter payment details - Supporting variable or fixed amounts (defaults to the original payment amount if not specified)  **Prerequisites:**  1. The initial payment must be created with the `sequence` parameter 2. The initial payment will return a `sequenceId` in the response 3. This `sequenceId` must be provided in the URL path when making subsequent recurring charges  Ideal for subscription services, membership renewals, and installment payments.  **Need more advanced subscription management?** For comprehensive subscription management with features like billing cycles, trial periods, and automatic recurring billing, consider using the [Subscriptions API](https://docs.monei.com/apis/rest/subscriptions/) instead. It provides a complete solution for creating and managing subscription-based services.
     * @summary Recurring Payment
     * @param {string} sequenceId The sequence ID
     * @param {RecurringPaymentRequest} [recurringPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async recurring(sequenceId, recurringPaymentRequest, options) {
      var _configuration$server6, _operationServerMap$P6;
      const localVarAxiosArgs = await localVarAxiosParamCreator.recurring(sequenceId, recurringPaymentRequest, options);
      const localVarOperationServerIndex = (_configuration$server6 = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server6 : 0;
      const localVarOperationServerBasePath = (_operationServerMap$P6 = operationServerMap['PaymentsApi.recurring']) == null || (_operationServerMap$P6 = _operationServerMap$P6[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$P6.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns funds from a completed payment back to the customer\'s original payment method.  **Refund options:**  - **Full refund**: Return the entire payment amount - **Partial refund**: Specify an amount less than the original payment - **Multiple partial refunds**: Issue several partial refunds until the total payment amount is reached  **Limitations:**  - You can only refund payments that have been successfully processed - A payment can only be refunded up to its original amount - Once fully refunded, a payment cannot be refunded again - Attempting to refund more than the remaining available amount will result in an error
     * @summary Refund Payment
     * @param {string} id The payment ID
     * @param {RefundPaymentRequest} [refundPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refund(id, refundPaymentRequest, options) {
      var _configuration$server7, _operationServerMap$P7;
      const localVarAxiosArgs = await localVarAxiosParamCreator.refund(id, refundPaymentRequest, options);
      const localVarOperationServerIndex = (_configuration$server7 = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server7 : 0;
      const localVarOperationServerBasePath = (_operationServerMap$P7 = operationServerMap['PaymentsApi.refund']) == null || (_operationServerMap$P7 = _operationServerMap$P7[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$P7.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Sends a payment link to the customer through their preferred communication channel.  **This API can only be used for payments with the following status:**  - Pending  **Delivery channels are automatically selected based on available customer information:**  - If customer email is available: Link is sent via email - If customer phone is available: Link is sent via WhatsApp - If WhatsApp delivery fails: Link is sent via SMS as a fallback  The payment link allows customers to complete the payment at their convenience using their preferred payment method on the secure MONEI payment page. If no customer contact information is provided, the system will use the details stored in the payment record.
     * @summary Send Payment Link
     * @param {string} id The payment ID
     * @param {SendPaymentLinkRequest} [sendPaymentLinkRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendLink(id, sendPaymentLinkRequest, options) {
      var _configuration$server8, _operationServerMap$P8;
      const localVarAxiosArgs = await localVarAxiosParamCreator.sendLink(id, sendPaymentLinkRequest, options);
      const localVarOperationServerIndex = (_configuration$server8 = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server8 : 0;
      const localVarOperationServerBasePath = (_operationServerMap$P8 = operationServerMap['PaymentsApi.sendLink']) == null || (_operationServerMap$P8 = _operationServerMap$P8[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$P8.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Sends a payment receipt to the customer through their preferred communication channel.  **This API can only be used for payments with the following status:**  - Succeeded  **Delivery channels are automatically selected based on available customer information:**  - If customer email is available: Receipt is sent via email - If customer phone is available: Receipt is sent via WhatsApp - If WhatsApp delivery fails: Receipt is sent via SMS as a fallback  The receipt includes payment details such as amount, date, transaction ID, and merchant information, providing customers with a record of their successful transaction. If no customer contact information is provided, the system will use the details stored in the payment record.
     * @summary Send Payment Receipt
     * @param {string} id The payment ID
     * @param {SendPaymentReceiptRequest} [sendPaymentReceiptRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendReceipt(id, sendPaymentReceiptRequest, options) {
      var _configuration$server9, _operationServerMap$P9;
      const localVarAxiosArgs = await localVarAxiosParamCreator.sendReceipt(id, sendPaymentReceiptRequest, options);
      const localVarOperationServerIndex = (_configuration$server9 = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server9 : 0;
      const localVarOperationServerBasePath = (_operationServerMap$P9 = operationServerMap['PaymentsApi.sendReceipt']) == null || (_operationServerMap$P9 = _operationServerMap$P9[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$P9.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Sends a direct payment request to the customer\'s phone with smart channel selection.  **Smart delivery logic based on customer phone capabilities:**  - If the phone number is registered with Bizum and that payment method is available:   The customer receives a push notification in their banking app to instantly approve the payment - If Bizum is not available or the phone is not registered with Bizum:   The customer receives a payment link via WhatsApp to complete the payment  This endpoint provides a streamlined payment experience, especially for Spanish customers with Bizum integration, enabling quick and convenient mobile payments.
     * @summary Send Payment Request
     * @param {string} id The payment ID
     * @param {SendPaymentRequestRequest} sendPaymentRequestRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendRequest(id, sendPaymentRequestRequest, options) {
      var _configuration$server10, _operationServerMap$P10;
      const localVarAxiosArgs = await localVarAxiosParamCreator.sendRequest(id, sendPaymentRequestRequest, options);
      const localVarOperationServerIndex = (_configuration$server10 = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server10 : 0;
      const localVarOperationServerBasePath = (_operationServerMap$P10 = operationServerMap['PaymentsApi.sendRequest']) == null || (_operationServerMap$P10 = _operationServerMap$P10[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$P10.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    }
  };
};
/**
 * PaymentsApi - factory interface
 * @export
 */
const PaymentsApiFactory = function PaymentsApiFactory(configuration, basePath, axios) {
  const localVarFp = PaymentsApiFp(configuration);
  return {
    /**
     * Releases reserved funds from a previously authorized payment. This endpoint can only be used with payments in `AUTHORIZED` status.  This operation is part of the two-step authorization flow:  1. **Authorize**: Create a payment with `transactionType: AUTH` to reserve funds 2. **Cancel**: Release the reserved funds if you decide not to capture the payment  Cancellation makes the reserved funds available to the customer again and prevents you from being able to capture those funds in the future. Once cancelled, an authorization cannot be reactivated.
     * @summary Cancel Payment
     * @param {string} id The payment ID
     * @param {CancelPaymentRequest} [cancelPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancel(id, cancelPaymentRequest, options) {
      return localVarFp.cancel(id, cancelPaymentRequest, options).then(request => request(axios, basePath));
    },
    /**
     * Captures funds from a previously authorized payment. This endpoint can only be used with payments in `AUTHORIZED` status.  This operation completes the two-step authorization flow:  1. **Authorize**: Create a payment with `transactionType: AUTH` to reserve funds 2. **Capture**: Transfer the reserved funds to your account when ready to fulfill the order  **Important**: Authorized payments expire after exactly seven days. After expiration, they will be marked as `EXPIRED` and can no longer be captured. Be sure to capture funds within this timeframe or communicate with your customer about a new payment.
     * @summary Capture Payment
     * @param {string} id The payment ID
     * @param {CapturePaymentRequest} [capturePaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    capture(id, capturePaymentRequest, options) {
      return localVarFp.capture(id, capturePaymentRequest, options).then(request => request(axios, basePath));
    },
    /**
     * Confirms a payment that was created without payment details. This endpoint can only be used with payments in `PENDING` status.  The two-step payment flow:  1. **Create**: First, create a payment without payment details (status: `PENDING`) 2. **Confirm**: Then provide payment details to complete the transaction  When confirming a payment, you can use:  - A newly generated `paymentToken` from [monei.js Components](https://docs.monei.com/monei-js/overview/) - A permanent `paymentToken` from a previous payment (generated with `generatePaymentToken: true`)  Using permanent payment tokens enables one-click checkout experiences for returning customers without requiring them to re-enter their payment information.  You can provide additional customer information during confirmation, which will override any corresponding information originally passed in the payment creation request.
     * @summary Confirm Payment
     * @param {string} id The payment ID
     * @param {ConfirmPaymentRequest} [confirmPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirm(id, confirmPaymentRequest, options) {
      return localVarFp.confirm(id, confirmPaymentRequest, options).then(request => request(axios, basePath));
    },
    /**
     * Creates a new payment with the specified parameters.  You can create a payment in two ways:  1. **Immediate processing**: Provide a `paymentToken` or `paymentMethod` - The payment will be processed instantly 2. **Deferred processing**: Create without payment details - The payment remains in `PENDING` status until you    confirm it later using the [confirm endpoint](https://docs.monei.com/apis/rest/payments-confirm/)  When creating a payment without payment details, you can redirect customers to the hosted payment page where they can select their preferred payment method and complete the transaction.  For immediate processing, use one of these token options:  - A temporary `paymentToken` generated on the frontend using [monei.js Components](https://docs.monei.com/monei-js/overview/) - A permanent `paymentToken` from a previous successful payment (when `generatePaymentToken: true` was included)  Permanent tokens enable one-click checkout experiences for returning customers by allowing you to securely store and reuse payment details without requiring customers to re-enter their information.
     * @summary Create Payment
     * @param {CreatePaymentRequest} createPaymentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(createPaymentRequest, options) {
      return localVarFp.create(createPaymentRequest, options).then(request => request(axios, basePath));
    },
    /**
     * Retrieves the complete details of an existing payment by its unique ID.  This endpoint returns all available information about the payment, including its current status, amount, customer details, timestamps, and transaction history. Use this to check the status of a payment, verify payment details, or retrieve information for your records.  Supply the unique payment ID that was returned from your previous request.
     * @summary Get Payment
     * @param {string} id The payment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get(id, options) {
      return localVarFp.get(id, options).then(request => request(axios, basePath));
    },
    /**
     * Creates a subsequent charge using the payment details from a previous transaction.  This endpoint enables recurring billing and subscription payments by:  - Using the same payment method as the original payment - Charging the customer without requiring them to re-enter payment details - Supporting variable or fixed amounts (defaults to the original payment amount if not specified)  **Prerequisites:**  1. The initial payment must be created with the `sequence` parameter 2. The initial payment will return a `sequenceId` in the response 3. This `sequenceId` must be provided in the URL path when making subsequent recurring charges  Ideal for subscription services, membership renewals, and installment payments.  **Need more advanced subscription management?** For comprehensive subscription management with features like billing cycles, trial periods, and automatic recurring billing, consider using the [Subscriptions API](https://docs.monei.com/apis/rest/subscriptions/) instead. It provides a complete solution for creating and managing subscription-based services.
     * @summary Recurring Payment
     * @param {string} sequenceId The sequence ID
     * @param {RecurringPaymentRequest} [recurringPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recurring(sequenceId, recurringPaymentRequest, options) {
      return localVarFp.recurring(sequenceId, recurringPaymentRequest, options).then(request => request(axios, basePath));
    },
    /**
     * Returns funds from a completed payment back to the customer\'s original payment method.  **Refund options:**  - **Full refund**: Return the entire payment amount - **Partial refund**: Specify an amount less than the original payment - **Multiple partial refunds**: Issue several partial refunds until the total payment amount is reached  **Limitations:**  - You can only refund payments that have been successfully processed - A payment can only be refunded up to its original amount - Once fully refunded, a payment cannot be refunded again - Attempting to refund more than the remaining available amount will result in an error
     * @summary Refund Payment
     * @param {string} id The payment ID
     * @param {RefundPaymentRequest} [refundPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refund(id, refundPaymentRequest, options) {
      return localVarFp.refund(id, refundPaymentRequest, options).then(request => request(axios, basePath));
    },
    /**
     * Sends a payment link to the customer through their preferred communication channel.  **This API can only be used for payments with the following status:**  - Pending  **Delivery channels are automatically selected based on available customer information:**  - If customer email is available: Link is sent via email - If customer phone is available: Link is sent via WhatsApp - If WhatsApp delivery fails: Link is sent via SMS as a fallback  The payment link allows customers to complete the payment at their convenience using their preferred payment method on the secure MONEI payment page. If no customer contact information is provided, the system will use the details stored in the payment record.
     * @summary Send Payment Link
     * @param {string} id The payment ID
     * @param {SendPaymentLinkRequest} [sendPaymentLinkRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendLink(id, sendPaymentLinkRequest, options) {
      return localVarFp.sendLink(id, sendPaymentLinkRequest, options).then(request => request(axios, basePath));
    },
    /**
     * Sends a payment receipt to the customer through their preferred communication channel.  **This API can only be used for payments with the following status:**  - Succeeded  **Delivery channels are automatically selected based on available customer information:**  - If customer email is available: Receipt is sent via email - If customer phone is available: Receipt is sent via WhatsApp - If WhatsApp delivery fails: Receipt is sent via SMS as a fallback  The receipt includes payment details such as amount, date, transaction ID, and merchant information, providing customers with a record of their successful transaction. If no customer contact information is provided, the system will use the details stored in the payment record.
     * @summary Send Payment Receipt
     * @param {string} id The payment ID
     * @param {SendPaymentReceiptRequest} [sendPaymentReceiptRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendReceipt(id, sendPaymentReceiptRequest, options) {
      return localVarFp.sendReceipt(id, sendPaymentReceiptRequest, options).then(request => request(axios, basePath));
    },
    /**
     * Sends a direct payment request to the customer\'s phone with smart channel selection.  **Smart delivery logic based on customer phone capabilities:**  - If the phone number is registered with Bizum and that payment method is available:   The customer receives a push notification in their banking app to instantly approve the payment - If Bizum is not available or the phone is not registered with Bizum:   The customer receives a payment link via WhatsApp to complete the payment  This endpoint provides a streamlined payment experience, especially for Spanish customers with Bizum integration, enabling quick and convenient mobile payments.
     * @summary Send Payment Request
     * @param {string} id The payment ID
     * @param {SendPaymentRequestRequest} sendPaymentRequestRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendRequest(id, sendPaymentRequestRequest, options) {
      return localVarFp.sendRequest(id, sendPaymentRequestRequest, options).then(request => request(axios, basePath));
    }
  };
};
/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
class PaymentsApi extends BaseAPI {
  /**
   * Releases reserved funds from a previously authorized payment. This endpoint can only be used with payments in `AUTHORIZED` status.  This operation is part of the two-step authorization flow:  1. **Authorize**: Create a payment with `transactionType: AUTH` to reserve funds 2. **Cancel**: Release the reserved funds if you decide not to capture the payment  Cancellation makes the reserved funds available to the customer again and prevents you from being able to capture those funds in the future. Once cancelled, an authorization cannot be reactivated.
   * @summary Cancel Payment
   * @param {string} id The payment ID
   * @param {CancelPaymentRequest} [cancelPaymentRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  cancel(id, cancelPaymentRequest, options) {
    return PaymentsApiFp(this.configuration).cancel(id, cancelPaymentRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Captures funds from a previously authorized payment. This endpoint can only be used with payments in `AUTHORIZED` status.  This operation completes the two-step authorization flow:  1. **Authorize**: Create a payment with `transactionType: AUTH` to reserve funds 2. **Capture**: Transfer the reserved funds to your account when ready to fulfill the order  **Important**: Authorized payments expire after exactly seven days. After expiration, they will be marked as `EXPIRED` and can no longer be captured. Be sure to capture funds within this timeframe or communicate with your customer about a new payment.
   * @summary Capture Payment
   * @param {string} id The payment ID
   * @param {CapturePaymentRequest} [capturePaymentRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  capture(id, capturePaymentRequest, options) {
    return PaymentsApiFp(this.configuration).capture(id, capturePaymentRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Confirms a payment that was created without payment details. This endpoint can only be used with payments in `PENDING` status.  The two-step payment flow:  1. **Create**: First, create a payment without payment details (status: `PENDING`) 2. **Confirm**: Then provide payment details to complete the transaction  When confirming a payment, you can use:  - A newly generated `paymentToken` from [monei.js Components](https://docs.monei.com/monei-js/overview/) - A permanent `paymentToken` from a previous payment (generated with `generatePaymentToken: true`)  Using permanent payment tokens enables one-click checkout experiences for returning customers without requiring them to re-enter their payment information.  You can provide additional customer information during confirmation, which will override any corresponding information originally passed in the payment creation request.
   * @summary Confirm Payment
   * @param {string} id The payment ID
   * @param {ConfirmPaymentRequest} [confirmPaymentRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  confirm(id, confirmPaymentRequest, options) {
    return PaymentsApiFp(this.configuration).confirm(id, confirmPaymentRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Creates a new payment with the specified parameters.  You can create a payment in two ways:  1. **Immediate processing**: Provide a `paymentToken` or `paymentMethod` - The payment will be processed instantly 2. **Deferred processing**: Create without payment details - The payment remains in `PENDING` status until you    confirm it later using the [confirm endpoint](https://docs.monei.com/apis/rest/payments-confirm/)  When creating a payment without payment details, you can redirect customers to the hosted payment page where they can select their preferred payment method and complete the transaction.  For immediate processing, use one of these token options:  - A temporary `paymentToken` generated on the frontend using [monei.js Components](https://docs.monei.com/monei-js/overview/) - A permanent `paymentToken` from a previous successful payment (when `generatePaymentToken: true` was included)  Permanent tokens enable one-click checkout experiences for returning customers by allowing you to securely store and reuse payment details without requiring customers to re-enter their information.
   * @summary Create Payment
   * @param {CreatePaymentRequest} createPaymentRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  create(createPaymentRequest, options) {
    return PaymentsApiFp(this.configuration).create(createPaymentRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Retrieves the complete details of an existing payment by its unique ID.  This endpoint returns all available information about the payment, including its current status, amount, customer details, timestamps, and transaction history. Use this to check the status of a payment, verify payment details, or retrieve information for your records.  Supply the unique payment ID that was returned from your previous request.
   * @summary Get Payment
   * @param {string} id The payment ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  get(id, options) {
    return PaymentsApiFp(this.configuration).get(id, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Creates a subsequent charge using the payment details from a previous transaction.  This endpoint enables recurring billing and subscription payments by:  - Using the same payment method as the original payment - Charging the customer without requiring them to re-enter payment details - Supporting variable or fixed amounts (defaults to the original payment amount if not specified)  **Prerequisites:**  1. The initial payment must be created with the `sequence` parameter 2. The initial payment will return a `sequenceId` in the response 3. This `sequenceId` must be provided in the URL path when making subsequent recurring charges  Ideal for subscription services, membership renewals, and installment payments.  **Need more advanced subscription management?** For comprehensive subscription management with features like billing cycles, trial periods, and automatic recurring billing, consider using the [Subscriptions API](https://docs.monei.com/apis/rest/subscriptions/) instead. It provides a complete solution for creating and managing subscription-based services.
   * @summary Recurring Payment
   * @param {string} sequenceId The sequence ID
   * @param {RecurringPaymentRequest} [recurringPaymentRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  recurring(sequenceId, recurringPaymentRequest, options) {
    return PaymentsApiFp(this.configuration).recurring(sequenceId, recurringPaymentRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Returns funds from a completed payment back to the customer\'s original payment method.  **Refund options:**  - **Full refund**: Return the entire payment amount - **Partial refund**: Specify an amount less than the original payment - **Multiple partial refunds**: Issue several partial refunds until the total payment amount is reached  **Limitations:**  - You can only refund payments that have been successfully processed - A payment can only be refunded up to its original amount - Once fully refunded, a payment cannot be refunded again - Attempting to refund more than the remaining available amount will result in an error
   * @summary Refund Payment
   * @param {string} id The payment ID
   * @param {RefundPaymentRequest} [refundPaymentRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  refund(id, refundPaymentRequest, options) {
    return PaymentsApiFp(this.configuration).refund(id, refundPaymentRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Sends a payment link to the customer through their preferred communication channel.  **This API can only be used for payments with the following status:**  - Pending  **Delivery channels are automatically selected based on available customer information:**  - If customer email is available: Link is sent via email - If customer phone is available: Link is sent via WhatsApp - If WhatsApp delivery fails: Link is sent via SMS as a fallback  The payment link allows customers to complete the payment at their convenience using their preferred payment method on the secure MONEI payment page. If no customer contact information is provided, the system will use the details stored in the payment record.
   * @summary Send Payment Link
   * @param {string} id The payment ID
   * @param {SendPaymentLinkRequest} [sendPaymentLinkRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  sendLink(id, sendPaymentLinkRequest, options) {
    return PaymentsApiFp(this.configuration).sendLink(id, sendPaymentLinkRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Sends a payment receipt to the customer through their preferred communication channel.  **This API can only be used for payments with the following status:**  - Succeeded  **Delivery channels are automatically selected based on available customer information:**  - If customer email is available: Receipt is sent via email - If customer phone is available: Receipt is sent via WhatsApp - If WhatsApp delivery fails: Receipt is sent via SMS as a fallback  The receipt includes payment details such as amount, date, transaction ID, and merchant information, providing customers with a record of their successful transaction. If no customer contact information is provided, the system will use the details stored in the payment record.
   * @summary Send Payment Receipt
   * @param {string} id The payment ID
   * @param {SendPaymentReceiptRequest} [sendPaymentReceiptRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  sendReceipt(id, sendPaymentReceiptRequest, options) {
    return PaymentsApiFp(this.configuration).sendReceipt(id, sendPaymentReceiptRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Sends a direct payment request to the customer\'s phone with smart channel selection.  **Smart delivery logic based on customer phone capabilities:**  - If the phone number is registered with Bizum and that payment method is available:   The customer receives a push notification in their banking app to instantly approve the payment - If Bizum is not available or the phone is not registered with Bizum:   The customer receives a payment link via WhatsApp to complete the payment  This endpoint provides a streamlined payment experience, especially for Spanish customers with Bizum integration, enabling quick and convenient mobile payments.
   * @summary Send Payment Request
   * @param {string} id The payment ID
   * @param {SendPaymentRequestRequest} sendPaymentRequestRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  sendRequest(id, sendPaymentRequestRequest, options) {
    return PaymentsApiFp(this.configuration).sendRequest(id, sendPaymentRequestRequest, options).then(request => request(this.axios, this.basePath));
  }
}

/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
const SubscriptionsApiAxiosParamCreator = function SubscriptionsApiAxiosParamCreator(configuration) {
  return {
    /**
     * Activates a subscription by attaching a payment method and initiating the billing cycle.  **Activation Process**:  1. This endpoint transitions a `PENDING` subscription to `ACTIVE` status 2. An initial payment is created to validate the payment method:    - For regular subscriptions: First billing cycle payment is processed immediately    - For trial subscriptions: A zero-amount payment is created to verify the payment method  **Payment Method Updates**: If the subscription is already active, this endpoint can be used to update the payment method. The update process creates a zero-amount payment to verify the new payment method works correctly.  **Important Notes**:  - Subscription billing begins immediately upon successful activation (unless in trial period) - The payment method provided will be used for all future recurring charges - Activation failures (due to invalid payment method) will keep the subscription in `PENDING` status
     * @summary Activate Subscription
     * @param {string} id The subscription ID
     * @param {ActivateSubscriptionRequest} [activateSubscriptionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activate: async (id, activateSubscriptionRequest, options = {}) => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('activate', 'id', id);
      const localVarPath = `/subscriptions/{id}/activate`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'POST'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      localVarHeaderParameter['Content-Type'] = 'application/json';
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      localVarRequestOptions.data = serializeDataIfNeeded(activateSubscriptionRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Cancels an active subscription, permanently stopping the billing cycle.  **Cancellation Effects**:  - The subscription status changes to `CANCELED` - No further charges will be processed - Access to subscription services typically ends immediately or at period end (depending on your business rules)  **Important Notes**:  - Cancellation is permanent and cannot be undone - To restart service, a new subscription must be created - Consider using `pauseAtPeriodEnd` or `cancelAtPeriodEnd` for softer transitions  Use this endpoint when a customer wishes to completely terminate their subscription.
     * @summary Cancel Subscription
     * @param {string} id The subscription ID
     * @param {CancelSubscriptionRequest} [cancelSubscriptionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancel: async (id, cancelSubscriptionRequest, options = {}) => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('cancel', 'id', id);
      const localVarPath = `/subscriptions/{id}/cancel`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'POST'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      localVarHeaderParameter['Content-Type'] = 'application/json';
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      localVarRequestOptions.data = serializeDataIfNeeded(cancelSubscriptionRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new subscription with the specified parameters.  **Subscription Lifecycle**:  1. When first created, the subscription has a `PENDING` status 2. To initiate billing, you must call the [activate endpoint](https://docs.monei.com/apis/rest/subscriptions-activate/) with payment details 3. Once activated, the subscription will automatically bill according to the configured interval  **Key Configuration Parameters**:  - **Billing settings**: Amount, currency, interval (daily, weekly, monthly, yearly) - **Schedule customization**: Interval count, trial period duration - **Customer information**: Contact details, billing and shipping addresses - **Communication**: Callback URLs for webhook notifications about subscription events  **Best Practices**:  - Set clear, descriptive names for subscriptions to help with identification - Configure appropriate webhook notifications to monitor subscription status changes - Consider offering trial periods to increase customer conversion rates - Use metadata to store additional information relevant to your business logic
     * @summary Create Subscription
     * @param {CreateSubscriptionRequest} createSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (createSubscriptionRequest, options = {}) => {
      // verify required parameter 'createSubscriptionRequest' is not null or undefined
      assertParamExists('create', 'createSubscriptionRequest', createSubscriptionRequest);
      const localVarPath = `/subscriptions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'POST'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      localVarHeaderParameter['Content-Type'] = 'application/json';
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      localVarRequestOptions.data = serializeDataIfNeeded(createSubscriptionRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieves the complete details of an existing subscription by its unique ID.  This endpoint returns comprehensive information about the subscription, including:  - Current status and lifecycle details (active, paused, canceled) - Billing configuration (amount, currency, interval) - Schedule information (current period, next payment date) - Customer and payment method details - Payment history (including last payment status) - Trial period information (if applicable)  Use this endpoint to check subscription status, verify billing details, or retrieve information needed for customer support inquiries.
     * @summary Get Subscription
     * @param {string} id The subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get: async (id, options = {}) => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('get', 'id', id);
      const localVarPath = `/subscriptions/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'GET'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Pauses an active subscription, temporarily halting the billing cycle.  **Pause Effects**:  - Billing is immediately suspended - The subscription status changes to `PAUSED` - No charges will be processed while the subscription remains paused - The current billing period end date remains unchanged  **Use Cases**:  - Temporary service interruptions - Customer vacation or absence periods - Account maintenance or dispute resolution  To resume billing, use the [resume endpoint](https://docs.monei.com/apis/rest/subscriptions-resume/).
     * @summary Pause Subscription
     * @param {string} id The subscription ID
     * @param {PauseSubscriptionRequest} [pauseSubscriptionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pause: async (id, pauseSubscriptionRequest, options = {}) => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('pause', 'id', id);
      const localVarPath = `/subscriptions/{id}/pause`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'POST'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      localVarHeaderParameter['Content-Type'] = 'application/json';
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      localVarRequestOptions.data = serializeDataIfNeeded(pauseSubscriptionRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Resumes a previously paused subscription, reactivating the billing cycle.  **Resume Effects**:  - Billing is immediately reactivated - The subscription status changes from `PAUSED` to `ACTIVE` - The next billing date is recalculated based on the current date - Regular charging schedule resumes according to the subscription interval  **Important Notes**:  - No immediate charge is created when resuming (billing continues on next scheduled date) - Any pause duration is added to the current billing period, maintaining the expected number of billing cycles - If a significant time has passed, verify that the payment method is still valid
     * @summary Resume Subscription
     * @param {string} id The subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resume: async (id, options = {}) => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('resume', 'id', id);
      const localVarPath = `/subscriptions/{id}/resume`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'POST'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Sends a subscription activation link to the customer through their preferred communication channel.  **This API can only be used for subscriptions with the following status:**  - Pending  **Delivery channels are automatically selected based on available customer information:**  - If customer email is available: Link is sent via email - If customer phone is available: Link is sent via WhatsApp - If WhatsApp delivery fails: Link is sent via SMS as a fallback  The subscription activation link allows customers to complete their subscription setup by providing payment details on the secure MONEI payment page. If no customer contact information is provided, the system will use the details stored in the subscription record.
     * @summary Send Subscription Link
     * @param {string} id The subscription ID
     * @param {SendSubscriptionLinkRequest} [sendSubscriptionLinkRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendLink: async (id, sendSubscriptionLinkRequest, options = {}) => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('sendLink', 'id', id);
      const localVarPath = `/subscriptions/{id}/link`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'POST'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      localVarHeaderParameter['Content-Type'] = 'application/json';
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      localVarRequestOptions.data = serializeDataIfNeeded(sendSubscriptionLinkRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Sends subscription status information to the customer through their preferred communication channel.  **This API can only be used for subscriptions with the following statuses:**  - Active - Trialing - Past due  **Delivery channels are automatically selected based on available customer information:**  - If customer email is available: Status is sent via email - If customer phone is available: Status is sent via WhatsApp - If WhatsApp delivery fails: Status is sent via SMS as a fallback  The status notification includes subscription details such as current status, upcoming payments, and recent changes. If no customer contact information is provided, the system will use the details stored in the subscription record.  **Email notifications include contextual action links based on subscription status:**  - For past due subscriptions: A link to reactivate the subscription - For active and trialing subscriptions: A link to update the payment method  You can specify the customer\'s email or phone number, the preferred communication channel (email or SMS), and the language for the message.
     * @summary Send Subscription Status
     * @param {string} id The subscription ID
     * @param {SendSubscriptionStatusRequest} [sendSubscriptionStatusRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendStatus: async (id, sendSubscriptionStatusRequest, options = {}) => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('sendStatus', 'id', id);
      const localVarPath = `/subscriptions/{id}/status`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'POST'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      localVarHeaderParameter['Content-Type'] = 'application/json';
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      localVarRequestOptions.data = serializeDataIfNeeded(sendSubscriptionStatusRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Updates the configuration of an existing subscription.  **Modifiable Parameters**:  - Billing information (amount, description) - Customer details (contact information, billing/shipping addresses) - Subscription settings (cancelAtPeriodEnd, pauseAtPeriodEnd) - Metadata (for your internal tracking)  **Update Effects**:  - Amount changes apply to the next billing cycle - Customer information updates take effect immediately - Setting `cancelAtPeriodEnd` to true will end the subscription after the current period - Setting `pauseAtPeriodEnd` to true will pause billing after the current period  **Note**: Some fundamental properties cannot be changed once a subscription is created, including currency and billing interval. To modify these, you would need to cancel the existing subscription and create a new one.
     * @summary Update Subscription
     * @param {string} id The subscription ID
     * @param {UpdateSubscriptionRequest} updateSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: async (id, updateSubscriptionRequest, options = {}) => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('update', 'id', id);
      // verify required parameter 'updateSubscriptionRequest' is not null or undefined
      assertParamExists('update', 'updateSubscriptionRequest', updateSubscriptionRequest);
      const localVarPath = `/subscriptions/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = _extends({
        method: 'PUT'
      }, baseOptions, options);
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      // authentication APIKey required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);
      localVarHeaderParameter['Content-Type'] = 'application/json';
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
      localVarRequestOptions.data = serializeDataIfNeeded(updateSubscriptionRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
const SubscriptionsApiFp = function SubscriptionsApiFp(configuration) {
  const localVarAxiosParamCreator = SubscriptionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Activates a subscription by attaching a payment method and initiating the billing cycle.  **Activation Process**:  1. This endpoint transitions a `PENDING` subscription to `ACTIVE` status 2. An initial payment is created to validate the payment method:    - For regular subscriptions: First billing cycle payment is processed immediately    - For trial subscriptions: A zero-amount payment is created to verify the payment method  **Payment Method Updates**: If the subscription is already active, this endpoint can be used to update the payment method. The update process creates a zero-amount payment to verify the new payment method works correctly.  **Important Notes**:  - Subscription billing begins immediately upon successful activation (unless in trial period) - The payment method provided will be used for all future recurring charges - Activation failures (due to invalid payment method) will keep the subscription in `PENDING` status
     * @summary Activate Subscription
     * @param {string} id The subscription ID
     * @param {ActivateSubscriptionRequest} [activateSubscriptionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async activate(id, activateSubscriptionRequest, options) {
      var _configuration$server, _operationServerMap$S;
      const localVarAxiosArgs = await localVarAxiosParamCreator.activate(id, activateSubscriptionRequest, options);
      const localVarOperationServerIndex = (_configuration$server = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server : 0;
      const localVarOperationServerBasePath = (_operationServerMap$S = operationServerMap['SubscriptionsApi.activate']) == null || (_operationServerMap$S = _operationServerMap$S[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$S.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Cancels an active subscription, permanently stopping the billing cycle.  **Cancellation Effects**:  - The subscription status changes to `CANCELED` - No further charges will be processed - Access to subscription services typically ends immediately or at period end (depending on your business rules)  **Important Notes**:  - Cancellation is permanent and cannot be undone - To restart service, a new subscription must be created - Consider using `pauseAtPeriodEnd` or `cancelAtPeriodEnd` for softer transitions  Use this endpoint when a customer wishes to completely terminate their subscription.
     * @summary Cancel Subscription
     * @param {string} id The subscription ID
     * @param {CancelSubscriptionRequest} [cancelSubscriptionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancel(id, cancelSubscriptionRequest, options) {
      var _configuration$server2, _operationServerMap$S2;
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(id, cancelSubscriptionRequest, options);
      const localVarOperationServerIndex = (_configuration$server2 = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server2 : 0;
      const localVarOperationServerBasePath = (_operationServerMap$S2 = operationServerMap['SubscriptionsApi.cancel']) == null || (_operationServerMap$S2 = _operationServerMap$S2[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$S2.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Creates a new subscription with the specified parameters.  **Subscription Lifecycle**:  1. When first created, the subscription has a `PENDING` status 2. To initiate billing, you must call the [activate endpoint](https://docs.monei.com/apis/rest/subscriptions-activate/) with payment details 3. Once activated, the subscription will automatically bill according to the configured interval  **Key Configuration Parameters**:  - **Billing settings**: Amount, currency, interval (daily, weekly, monthly, yearly) - **Schedule customization**: Interval count, trial period duration - **Customer information**: Contact details, billing and shipping addresses - **Communication**: Callback URLs for webhook notifications about subscription events  **Best Practices**:  - Set clear, descriptive names for subscriptions to help with identification - Configure appropriate webhook notifications to monitor subscription status changes - Consider offering trial periods to increase customer conversion rates - Use metadata to store additional information relevant to your business logic
     * @summary Create Subscription
     * @param {CreateSubscriptionRequest} createSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(createSubscriptionRequest, options) {
      var _configuration$server3, _operationServerMap$S3;
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(createSubscriptionRequest, options);
      const localVarOperationServerIndex = (_configuration$server3 = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server3 : 0;
      const localVarOperationServerBasePath = (_operationServerMap$S3 = operationServerMap['SubscriptionsApi.create']) == null || (_operationServerMap$S3 = _operationServerMap$S3[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$S3.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves the complete details of an existing subscription by its unique ID.  This endpoint returns comprehensive information about the subscription, including:  - Current status and lifecycle details (active, paused, canceled) - Billing configuration (amount, currency, interval) - Schedule information (current period, next payment date) - Customer and payment method details - Payment history (including last payment status) - Trial period information (if applicable)  Use this endpoint to check subscription status, verify billing details, or retrieve information needed for customer support inquiries.
     * @summary Get Subscription
     * @param {string} id The subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async get(id, options) {
      var _configuration$server4, _operationServerMap$S4;
      const localVarAxiosArgs = await localVarAxiosParamCreator.get(id, options);
      const localVarOperationServerIndex = (_configuration$server4 = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server4 : 0;
      const localVarOperationServerBasePath = (_operationServerMap$S4 = operationServerMap['SubscriptionsApi.get']) == null || (_operationServerMap$S4 = _operationServerMap$S4[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$S4.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Pauses an active subscription, temporarily halting the billing cycle.  **Pause Effects**:  - Billing is immediately suspended - The subscription status changes to `PAUSED` - No charges will be processed while the subscription remains paused - The current billing period end date remains unchanged  **Use Cases**:  - Temporary service interruptions - Customer vacation or absence periods - Account maintenance or dispute resolution  To resume billing, use the [resume endpoint](https://docs.monei.com/apis/rest/subscriptions-resume/).
     * @summary Pause Subscription
     * @param {string} id The subscription ID
     * @param {PauseSubscriptionRequest} [pauseSubscriptionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pause(id, pauseSubscriptionRequest, options) {
      var _configuration$server5, _operationServerMap$S5;
      const localVarAxiosArgs = await localVarAxiosParamCreator.pause(id, pauseSubscriptionRequest, options);
      const localVarOperationServerIndex = (_configuration$server5 = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server5 : 0;
      const localVarOperationServerBasePath = (_operationServerMap$S5 = operationServerMap['SubscriptionsApi.pause']) == null || (_operationServerMap$S5 = _operationServerMap$S5[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$S5.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Resumes a previously paused subscription, reactivating the billing cycle.  **Resume Effects**:  - Billing is immediately reactivated - The subscription status changes from `PAUSED` to `ACTIVE` - The next billing date is recalculated based on the current date - Regular charging schedule resumes according to the subscription interval  **Important Notes**:  - No immediate charge is created when resuming (billing continues on next scheduled date) - Any pause duration is added to the current billing period, maintaining the expected number of billing cycles - If a significant time has passed, verify that the payment method is still valid
     * @summary Resume Subscription
     * @param {string} id The subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resume(id, options) {
      var _configuration$server6, _operationServerMap$S6;
      const localVarAxiosArgs = await localVarAxiosParamCreator.resume(id, options);
      const localVarOperationServerIndex = (_configuration$server6 = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server6 : 0;
      const localVarOperationServerBasePath = (_operationServerMap$S6 = operationServerMap['SubscriptionsApi.resume']) == null || (_operationServerMap$S6 = _operationServerMap$S6[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$S6.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Sends a subscription activation link to the customer through their preferred communication channel.  **This API can only be used for subscriptions with the following status:**  - Pending  **Delivery channels are automatically selected based on available customer information:**  - If customer email is available: Link is sent via email - If customer phone is available: Link is sent via WhatsApp - If WhatsApp delivery fails: Link is sent via SMS as a fallback  The subscription activation link allows customers to complete their subscription setup by providing payment details on the secure MONEI payment page. If no customer contact information is provided, the system will use the details stored in the subscription record.
     * @summary Send Subscription Link
     * @param {string} id The subscription ID
     * @param {SendSubscriptionLinkRequest} [sendSubscriptionLinkRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendLink(id, sendSubscriptionLinkRequest, options) {
      var _configuration$server7, _operationServerMap$S7;
      const localVarAxiosArgs = await localVarAxiosParamCreator.sendLink(id, sendSubscriptionLinkRequest, options);
      const localVarOperationServerIndex = (_configuration$server7 = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server7 : 0;
      const localVarOperationServerBasePath = (_operationServerMap$S7 = operationServerMap['SubscriptionsApi.sendLink']) == null || (_operationServerMap$S7 = _operationServerMap$S7[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$S7.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Sends subscription status information to the customer through their preferred communication channel.  **This API can only be used for subscriptions with the following statuses:**  - Active - Trialing - Past due  **Delivery channels are automatically selected based on available customer information:**  - If customer email is available: Status is sent via email - If customer phone is available: Status is sent via WhatsApp - If WhatsApp delivery fails: Status is sent via SMS as a fallback  The status notification includes subscription details such as current status, upcoming payments, and recent changes. If no customer contact information is provided, the system will use the details stored in the subscription record.  **Email notifications include contextual action links based on subscription status:**  - For past due subscriptions: A link to reactivate the subscription - For active and trialing subscriptions: A link to update the payment method  You can specify the customer\'s email or phone number, the preferred communication channel (email or SMS), and the language for the message.
     * @summary Send Subscription Status
     * @param {string} id The subscription ID
     * @param {SendSubscriptionStatusRequest} [sendSubscriptionStatusRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendStatus(id, sendSubscriptionStatusRequest, options) {
      var _configuration$server8, _operationServerMap$S8;
      const localVarAxiosArgs = await localVarAxiosParamCreator.sendStatus(id, sendSubscriptionStatusRequest, options);
      const localVarOperationServerIndex = (_configuration$server8 = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server8 : 0;
      const localVarOperationServerBasePath = (_operationServerMap$S8 = operationServerMap['SubscriptionsApi.sendStatus']) == null || (_operationServerMap$S8 = _operationServerMap$S8[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$S8.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Updates the configuration of an existing subscription.  **Modifiable Parameters**:  - Billing information (amount, description) - Customer details (contact information, billing/shipping addresses) - Subscription settings (cancelAtPeriodEnd, pauseAtPeriodEnd) - Metadata (for your internal tracking)  **Update Effects**:  - Amount changes apply to the next billing cycle - Customer information updates take effect immediately - Setting `cancelAtPeriodEnd` to true will end the subscription after the current period - Setting `pauseAtPeriodEnd` to true will pause billing after the current period  **Note**: Some fundamental properties cannot be changed once a subscription is created, including currency and billing interval. To modify these, you would need to cancel the existing subscription and create a new one.
     * @summary Update Subscription
     * @param {string} id The subscription ID
     * @param {UpdateSubscriptionRequest} updateSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async update(id, updateSubscriptionRequest, options) {
      var _configuration$server9, _operationServerMap$S9;
      const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, updateSubscriptionRequest, options);
      const localVarOperationServerIndex = (_configuration$server9 = configuration == null ? void 0 : configuration.serverIndex) != null ? _configuration$server9 : 0;
      const localVarOperationServerBasePath = (_operationServerMap$S9 = operationServerMap['SubscriptionsApi.update']) == null || (_operationServerMap$S9 = _operationServerMap$S9[localVarOperationServerIndex]) == null ? void 0 : _operationServerMap$S9.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    }
  };
};
/**
 * SubscriptionsApi - factory interface
 * @export
 */
const SubscriptionsApiFactory = function SubscriptionsApiFactory(configuration, basePath, axios) {
  const localVarFp = SubscriptionsApiFp(configuration);
  return {
    /**
     * Activates a subscription by attaching a payment method and initiating the billing cycle.  **Activation Process**:  1. This endpoint transitions a `PENDING` subscription to `ACTIVE` status 2. An initial payment is created to validate the payment method:    - For regular subscriptions: First billing cycle payment is processed immediately    - For trial subscriptions: A zero-amount payment is created to verify the payment method  **Payment Method Updates**: If the subscription is already active, this endpoint can be used to update the payment method. The update process creates a zero-amount payment to verify the new payment method works correctly.  **Important Notes**:  - Subscription billing begins immediately upon successful activation (unless in trial period) - The payment method provided will be used for all future recurring charges - Activation failures (due to invalid payment method) will keep the subscription in `PENDING` status
     * @summary Activate Subscription
     * @param {string} id The subscription ID
     * @param {ActivateSubscriptionRequest} [activateSubscriptionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activate(id, activateSubscriptionRequest, options) {
      return localVarFp.activate(id, activateSubscriptionRequest, options).then(request => request(axios, basePath));
    },
    /**
     * Cancels an active subscription, permanently stopping the billing cycle.  **Cancellation Effects**:  - The subscription status changes to `CANCELED` - No further charges will be processed - Access to subscription services typically ends immediately or at period end (depending on your business rules)  **Important Notes**:  - Cancellation is permanent and cannot be undone - To restart service, a new subscription must be created - Consider using `pauseAtPeriodEnd` or `cancelAtPeriodEnd` for softer transitions  Use this endpoint when a customer wishes to completely terminate their subscription.
     * @summary Cancel Subscription
     * @param {string} id The subscription ID
     * @param {CancelSubscriptionRequest} [cancelSubscriptionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancel(id, cancelSubscriptionRequest, options) {
      return localVarFp.cancel(id, cancelSubscriptionRequest, options).then(request => request(axios, basePath));
    },
    /**
     * Creates a new subscription with the specified parameters.  **Subscription Lifecycle**:  1. When first created, the subscription has a `PENDING` status 2. To initiate billing, you must call the [activate endpoint](https://docs.monei.com/apis/rest/subscriptions-activate/) with payment details 3. Once activated, the subscription will automatically bill according to the configured interval  **Key Configuration Parameters**:  - **Billing settings**: Amount, currency, interval (daily, weekly, monthly, yearly) - **Schedule customization**: Interval count, trial period duration - **Customer information**: Contact details, billing and shipping addresses - **Communication**: Callback URLs for webhook notifications about subscription events  **Best Practices**:  - Set clear, descriptive names for subscriptions to help with identification - Configure appropriate webhook notifications to monitor subscription status changes - Consider offering trial periods to increase customer conversion rates - Use metadata to store additional information relevant to your business logic
     * @summary Create Subscription
     * @param {CreateSubscriptionRequest} createSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(createSubscriptionRequest, options) {
      return localVarFp.create(createSubscriptionRequest, options).then(request => request(axios, basePath));
    },
    /**
     * Retrieves the complete details of an existing subscription by its unique ID.  This endpoint returns comprehensive information about the subscription, including:  - Current status and lifecycle details (active, paused, canceled) - Billing configuration (amount, currency, interval) - Schedule information (current period, next payment date) - Customer and payment method details - Payment history (including last payment status) - Trial period information (if applicable)  Use this endpoint to check subscription status, verify billing details, or retrieve information needed for customer support inquiries.
     * @summary Get Subscription
     * @param {string} id The subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get(id, options) {
      return localVarFp.get(id, options).then(request => request(axios, basePath));
    },
    /**
     * Pauses an active subscription, temporarily halting the billing cycle.  **Pause Effects**:  - Billing is immediately suspended - The subscription status changes to `PAUSED` - No charges will be processed while the subscription remains paused - The current billing period end date remains unchanged  **Use Cases**:  - Temporary service interruptions - Customer vacation or absence periods - Account maintenance or dispute resolution  To resume billing, use the [resume endpoint](https://docs.monei.com/apis/rest/subscriptions-resume/).
     * @summary Pause Subscription
     * @param {string} id The subscription ID
     * @param {PauseSubscriptionRequest} [pauseSubscriptionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pause(id, pauseSubscriptionRequest, options) {
      return localVarFp.pause(id, pauseSubscriptionRequest, options).then(request => request(axios, basePath));
    },
    /**
     * Resumes a previously paused subscription, reactivating the billing cycle.  **Resume Effects**:  - Billing is immediately reactivated - The subscription status changes from `PAUSED` to `ACTIVE` - The next billing date is recalculated based on the current date - Regular charging schedule resumes according to the subscription interval  **Important Notes**:  - No immediate charge is created when resuming (billing continues on next scheduled date) - Any pause duration is added to the current billing period, maintaining the expected number of billing cycles - If a significant time has passed, verify that the payment method is still valid
     * @summary Resume Subscription
     * @param {string} id The subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resume(id, options) {
      return localVarFp.resume(id, options).then(request => request(axios, basePath));
    },
    /**
     * Sends a subscription activation link to the customer through their preferred communication channel.  **This API can only be used for subscriptions with the following status:**  - Pending  **Delivery channels are automatically selected based on available customer information:**  - If customer email is available: Link is sent via email - If customer phone is available: Link is sent via WhatsApp - If WhatsApp delivery fails: Link is sent via SMS as a fallback  The subscription activation link allows customers to complete their subscription setup by providing payment details on the secure MONEI payment page. If no customer contact information is provided, the system will use the details stored in the subscription record.
     * @summary Send Subscription Link
     * @param {string} id The subscription ID
     * @param {SendSubscriptionLinkRequest} [sendSubscriptionLinkRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendLink(id, sendSubscriptionLinkRequest, options) {
      return localVarFp.sendLink(id, sendSubscriptionLinkRequest, options).then(request => request(axios, basePath));
    },
    /**
     * Sends subscription status information to the customer through their preferred communication channel.  **This API can only be used for subscriptions with the following statuses:**  - Active - Trialing - Past due  **Delivery channels are automatically selected based on available customer information:**  - If customer email is available: Status is sent via email - If customer phone is available: Status is sent via WhatsApp - If WhatsApp delivery fails: Status is sent via SMS as a fallback  The status notification includes subscription details such as current status, upcoming payments, and recent changes. If no customer contact information is provided, the system will use the details stored in the subscription record.  **Email notifications include contextual action links based on subscription status:**  - For past due subscriptions: A link to reactivate the subscription - For active and trialing subscriptions: A link to update the payment method  You can specify the customer\'s email or phone number, the preferred communication channel (email or SMS), and the language for the message.
     * @summary Send Subscription Status
     * @param {string} id The subscription ID
     * @param {SendSubscriptionStatusRequest} [sendSubscriptionStatusRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendStatus(id, sendSubscriptionStatusRequest, options) {
      return localVarFp.sendStatus(id, sendSubscriptionStatusRequest, options).then(request => request(axios, basePath));
    },
    /**
     * Updates the configuration of an existing subscription.  **Modifiable Parameters**:  - Billing information (amount, description) - Customer details (contact information, billing/shipping addresses) - Subscription settings (cancelAtPeriodEnd, pauseAtPeriodEnd) - Metadata (for your internal tracking)  **Update Effects**:  - Amount changes apply to the next billing cycle - Customer information updates take effect immediately - Setting `cancelAtPeriodEnd` to true will end the subscription after the current period - Setting `pauseAtPeriodEnd` to true will pause billing after the current period  **Note**: Some fundamental properties cannot be changed once a subscription is created, including currency and billing interval. To modify these, you would need to cancel the existing subscription and create a new one.
     * @summary Update Subscription
     * @param {string} id The subscription ID
     * @param {UpdateSubscriptionRequest} updateSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(id, updateSubscriptionRequest, options) {
      return localVarFp.update(id, updateSubscriptionRequest, options).then(request => request(axios, basePath));
    }
  };
};
/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
class SubscriptionsApi extends BaseAPI {
  /**
   * Activates a subscription by attaching a payment method and initiating the billing cycle.  **Activation Process**:  1. This endpoint transitions a `PENDING` subscription to `ACTIVE` status 2. An initial payment is created to validate the payment method:    - For regular subscriptions: First billing cycle payment is processed immediately    - For trial subscriptions: A zero-amount payment is created to verify the payment method  **Payment Method Updates**: If the subscription is already active, this endpoint can be used to update the payment method. The update process creates a zero-amount payment to verify the new payment method works correctly.  **Important Notes**:  - Subscription billing begins immediately upon successful activation (unless in trial period) - The payment method provided will be used for all future recurring charges - Activation failures (due to invalid payment method) will keep the subscription in `PENDING` status
   * @summary Activate Subscription
   * @param {string} id The subscription ID
   * @param {ActivateSubscriptionRequest} [activateSubscriptionRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */
  activate(id, activateSubscriptionRequest, options) {
    return SubscriptionsApiFp(this.configuration).activate(id, activateSubscriptionRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Cancels an active subscription, permanently stopping the billing cycle.  **Cancellation Effects**:  - The subscription status changes to `CANCELED` - No further charges will be processed - Access to subscription services typically ends immediately or at period end (depending on your business rules)  **Important Notes**:  - Cancellation is permanent and cannot be undone - To restart service, a new subscription must be created - Consider using `pauseAtPeriodEnd` or `cancelAtPeriodEnd` for softer transitions  Use this endpoint when a customer wishes to completely terminate their subscription.
   * @summary Cancel Subscription
   * @param {string} id The subscription ID
   * @param {CancelSubscriptionRequest} [cancelSubscriptionRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */
  cancel(id, cancelSubscriptionRequest, options) {
    return SubscriptionsApiFp(this.configuration).cancel(id, cancelSubscriptionRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Creates a new subscription with the specified parameters.  **Subscription Lifecycle**:  1. When first created, the subscription has a `PENDING` status 2. To initiate billing, you must call the [activate endpoint](https://docs.monei.com/apis/rest/subscriptions-activate/) with payment details 3. Once activated, the subscription will automatically bill according to the configured interval  **Key Configuration Parameters**:  - **Billing settings**: Amount, currency, interval (daily, weekly, monthly, yearly) - **Schedule customization**: Interval count, trial period duration - **Customer information**: Contact details, billing and shipping addresses - **Communication**: Callback URLs for webhook notifications about subscription events  **Best Practices**:  - Set clear, descriptive names for subscriptions to help with identification - Configure appropriate webhook notifications to monitor subscription status changes - Consider offering trial periods to increase customer conversion rates - Use metadata to store additional information relevant to your business logic
   * @summary Create Subscription
   * @param {CreateSubscriptionRequest} createSubscriptionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */
  create(createSubscriptionRequest, options) {
    return SubscriptionsApiFp(this.configuration).create(createSubscriptionRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Retrieves the complete details of an existing subscription by its unique ID.  This endpoint returns comprehensive information about the subscription, including:  - Current status and lifecycle details (active, paused, canceled) - Billing configuration (amount, currency, interval) - Schedule information (current period, next payment date) - Customer and payment method details - Payment history (including last payment status) - Trial period information (if applicable)  Use this endpoint to check subscription status, verify billing details, or retrieve information needed for customer support inquiries.
   * @summary Get Subscription
   * @param {string} id The subscription ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */
  get(id, options) {
    return SubscriptionsApiFp(this.configuration).get(id, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Pauses an active subscription, temporarily halting the billing cycle.  **Pause Effects**:  - Billing is immediately suspended - The subscription status changes to `PAUSED` - No charges will be processed while the subscription remains paused - The current billing period end date remains unchanged  **Use Cases**:  - Temporary service interruptions - Customer vacation or absence periods - Account maintenance or dispute resolution  To resume billing, use the [resume endpoint](https://docs.monei.com/apis/rest/subscriptions-resume/).
   * @summary Pause Subscription
   * @param {string} id The subscription ID
   * @param {PauseSubscriptionRequest} [pauseSubscriptionRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */
  pause(id, pauseSubscriptionRequest, options) {
    return SubscriptionsApiFp(this.configuration).pause(id, pauseSubscriptionRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Resumes a previously paused subscription, reactivating the billing cycle.  **Resume Effects**:  - Billing is immediately reactivated - The subscription status changes from `PAUSED` to `ACTIVE` - The next billing date is recalculated based on the current date - Regular charging schedule resumes according to the subscription interval  **Important Notes**:  - No immediate charge is created when resuming (billing continues on next scheduled date) - Any pause duration is added to the current billing period, maintaining the expected number of billing cycles - If a significant time has passed, verify that the payment method is still valid
   * @summary Resume Subscription
   * @param {string} id The subscription ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */
  resume(id, options) {
    return SubscriptionsApiFp(this.configuration).resume(id, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Sends a subscription activation link to the customer through their preferred communication channel.  **This API can only be used for subscriptions with the following status:**  - Pending  **Delivery channels are automatically selected based on available customer information:**  - If customer email is available: Link is sent via email - If customer phone is available: Link is sent via WhatsApp - If WhatsApp delivery fails: Link is sent via SMS as a fallback  The subscription activation link allows customers to complete their subscription setup by providing payment details on the secure MONEI payment page. If no customer contact information is provided, the system will use the details stored in the subscription record.
   * @summary Send Subscription Link
   * @param {string} id The subscription ID
   * @param {SendSubscriptionLinkRequest} [sendSubscriptionLinkRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */
  sendLink(id, sendSubscriptionLinkRequest, options) {
    return SubscriptionsApiFp(this.configuration).sendLink(id, sendSubscriptionLinkRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Sends subscription status information to the customer through their preferred communication channel.  **This API can only be used for subscriptions with the following statuses:**  - Active - Trialing - Past due  **Delivery channels are automatically selected based on available customer information:**  - If customer email is available: Status is sent via email - If customer phone is available: Status is sent via WhatsApp - If WhatsApp delivery fails: Status is sent via SMS as a fallback  The status notification includes subscription details such as current status, upcoming payments, and recent changes. If no customer contact information is provided, the system will use the details stored in the subscription record.  **Email notifications include contextual action links based on subscription status:**  - For past due subscriptions: A link to reactivate the subscription - For active and trialing subscriptions: A link to update the payment method  You can specify the customer\'s email or phone number, the preferred communication channel (email or SMS), and the language for the message.
   * @summary Send Subscription Status
   * @param {string} id The subscription ID
   * @param {SendSubscriptionStatusRequest} [sendSubscriptionStatusRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */
  sendStatus(id, sendSubscriptionStatusRequest, options) {
    return SubscriptionsApiFp(this.configuration).sendStatus(id, sendSubscriptionStatusRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Updates the configuration of an existing subscription.  **Modifiable Parameters**:  - Billing information (amount, description) - Customer details (contact information, billing/shipping addresses) - Subscription settings (cancelAtPeriodEnd, pauseAtPeriodEnd) - Metadata (for your internal tracking)  **Update Effects**:  - Amount changes apply to the next billing cycle - Customer information updates take effect immediately - Setting `cancelAtPeriodEnd` to true will end the subscription after the current period - Setting `pauseAtPeriodEnd` to true will pause billing after the current period  **Note**: Some fundamental properties cannot be changed once a subscription is created, including currency and billing interval. To modify these, you would need to cancel the existing subscription and create a new one.
   * @summary Update Subscription
   * @param {string} id The subscription ID
   * @param {UpdateSubscriptionRequest} updateSubscriptionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */
  update(id, updateSubscriptionRequest, options) {
    return SubscriptionsApiFp(this.configuration).update(id, updateSubscriptionRequest, options).then(request => request(this.axios, this.basePath));
  }
}

/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * The MONEI API is organized around REST principles. Our API is designed to be intuitive and developer-friendly.  ### Base URL  All API requests should be made to:  ``` https://api.monei.com/v1 ```  ### Environment  MONEI provides two environments:  - **Test Environment**: For development and testing without processing real payments - **Live Environment**: For processing real transactions in production  ### Client Libraries  We provide official SDKs to simplify integration:  - [PHP SDK](https://github.com/MONEI/monei-php-sdk) - [Python SDK](https://github.com/MONEI/monei-python-sdk) - [Node.js SDK](https://github.com/MONEI/monei-node-sdk) - [Postman Collection](https://postman.monei.com/)  Our SDKs handle authentication, error handling, and request formatting automatically.  You can download the OpenAPI specification from the https://js.monei.com/api/v1/openapi.json and generate your own client library using the [OpenAPI Generator](https://openapi-generator.tech/).  ### Important Requirements  - All API requests must be made over HTTPS - If you are not using our official SDKs, you **must provide a valid `User-Agent` header** with each request - Requests without proper authentication will return a `401 Unauthorized` error  ### Error Handling  The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a `statusCode` attribute indicating the outcome of your request.  ### Rate Limits  The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a `429 Too Many Requests` status code.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class Configuration {
  constructor(param = {}) {
    var _param$baseOptions;
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    this.apiKey = void 0;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    this.username = void 0;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    this.password = void 0;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    this.accessToken = void 0;
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    this.basePath = void 0;
    /**
     * override server index
     *
     * @type {number}
     * @memberof Configuration
     */
    this.serverIndex = void 0;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    this.baseOptions = void 0;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    this.formDataCtor = void 0;
    this.apiKey = param.apiKey;
    this.username = param.username;
    this.password = param.password;
    this.accessToken = param.accessToken;
    this.basePath = param.basePath;
    this.serverIndex = param.serverIndex;
    this.baseOptions = _extends({}, param.baseOptions, {
      headers: _extends({}, (_param$baseOptions = param.baseOptions) == null ? void 0 : _param$baseOptions.headers)
    });
    this.formDataCtor = param.formDataCtor;
  }
  /**
   * Check if the given MIME is a JSON MIME.
   * JSON MIME examples:
   *   application/json
   *   application/json; charset=UTF8
   *   APPLICATION/JSON
   *   application/vnd.company+json
   * @param mime - MIME (Multipurpose Internet Mail Extensions)
   * @return True if the given MIME is JSON, false otherwise.
   */
  isJsonMime(mime) {
    const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
    return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
  }
}

/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * The MONEI API is organized around REST principles. Our API is designed to be intuitive and developer-friendly.  ### Base URL  All API requests should be made to:  ``` https://api.monei.com/v1 ```  ### Environment  MONEI provides two environments:  - **Test Environment**: For development and testing without processing real payments - **Live Environment**: For processing real transactions in production  ### Client Libraries  We provide official SDKs to simplify integration:  - [PHP SDK](https://github.com/MONEI/monei-php-sdk) - [Python SDK](https://github.com/MONEI/monei-python-sdk) - [Node.js SDK](https://github.com/MONEI/monei-node-sdk) - [Postman Collection](https://postman.monei.com/)  Our SDKs handle authentication, error handling, and request formatting automatically.  You can download the OpenAPI specification from the https://js.monei.com/api/v1/openapi.json and generate your own client library using the [OpenAPI Generator](https://openapi-generator.tech/).  ### Important Requirements  - All API requests must be made over HTTPS - If you are not using our official SDKs, you **must provide a valid `User-Agent` header** with each request - Requests without proper authentication will return a `401 Unauthorized` error  ### Error Handling  The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a `statusCode` attribute indicating the outcome of your request.  ### Rate Limits  The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a `429 Too Many Requests` status code.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The reason for canceling the Payment.
 * @export
 * @enum {string}
 */
const PaymentCancellationReason = {
  DUPLICATED: 'duplicated',
  FRAUDULENT: 'fraudulent',
  REQUESTED_BY_CUSTOMER: 'requested_by_customer'
};

/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * The MONEI API is organized around REST principles. Our API is designed to be intuitive and developer-friendly.  ### Base URL  All API requests should be made to:  ``` https://api.monei.com/v1 ```  ### Environment  MONEI provides two environments:  - **Test Environment**: For development and testing without processing real payments - **Live Environment**: For processing real transactions in production  ### Client Libraries  We provide official SDKs to simplify integration:  - [PHP SDK](https://github.com/MONEI/monei-php-sdk) - [Python SDK](https://github.com/MONEI/monei-python-sdk) - [Node.js SDK](https://github.com/MONEI/monei-node-sdk) - [Postman Collection](https://postman.monei.com/)  Our SDKs handle authentication, error handling, and request formatting automatically.  You can download the OpenAPI specification from the https://js.monei.com/api/v1/openapi.json and generate your own client library using the [OpenAPI Generator](https://openapi-generator.tech/).  ### Important Requirements  - All API requests must be made over HTTPS - If you are not using our official SDKs, you **must provide a valid `User-Agent` header** with each request - Requests without proper authentication will return a `401 Unauthorized` error  ### Error Handling  The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a `statusCode` attribute indicating the outcome of your request.  ### Rate Limits  The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a `429 Too Many Requests` status code.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The reason of the last refund transaction.
 * @export
 * @enum {string}
 */
const PaymentLastRefundReason = {
  DUPLICATED: 'duplicated',
  FRAUDULENT: 'fraudulent',
  REQUESTED_BY_CUSTOMER: 'requested_by_customer'
};

/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * The MONEI API is organized around REST principles. Our API is designed to be intuitive and developer-friendly.  ### Base URL  All API requests should be made to:  ``` https://api.monei.com/v1 ```  ### Environment  MONEI provides two environments:  - **Test Environment**: For development and testing without processing real payments - **Live Environment**: For processing real transactions in production  ### Client Libraries  We provide official SDKs to simplify integration:  - [PHP SDK](https://github.com/MONEI/monei-php-sdk) - [Python SDK](https://github.com/MONEI/monei-python-sdk) - [Node.js SDK](https://github.com/MONEI/monei-node-sdk) - [Postman Collection](https://postman.monei.com/)  Our SDKs handle authentication, error handling, and request formatting automatically.  You can download the OpenAPI specification from the https://js.monei.com/api/v1/openapi.json and generate your own client library using the [OpenAPI Generator](https://openapi-generator.tech/).  ### Important Requirements  - All API requests must be made over HTTPS - If you are not using our official SDKs, you **must provide a valid `User-Agent` header** with each request - Requests without proper authentication will return a `401 Unauthorized` error  ### Error Handling  The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a `statusCode` attribute indicating the outcome of your request.  ### Rate Limits  The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a `429 Too Many Requests` status code.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The channel used to send the payment message.
 * @export
 * @enum {string}
 */
const PaymentMessageChannel = {
  EMAIL: 'EMAIL',
  WHATSAPP: 'WHATSAPP',
  SMS: 'SMS'
};

/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * The MONEI API is organized around REST principles. Our API is designed to be intuitive and developer-friendly.  ### Base URL  All API requests should be made to:  ``` https://api.monei.com/v1 ```  ### Environment  MONEI provides two environments:  - **Test Environment**: For development and testing without processing real payments - **Live Environment**: For processing real transactions in production  ### Client Libraries  We provide official SDKs to simplify integration:  - [PHP SDK](https://github.com/MONEI/monei-php-sdk) - [Python SDK](https://github.com/MONEI/monei-python-sdk) - [Node.js SDK](https://github.com/MONEI/monei-node-sdk) - [Postman Collection](https://postman.monei.com/)  Our SDKs handle authentication, error handling, and request formatting automatically.  You can download the OpenAPI specification from the https://js.monei.com/api/v1/openapi.json and generate your own client library using the [OpenAPI Generator](https://openapi-generator.tech/).  ### Important Requirements  - All API requests must be made over HTTPS - If you are not using our official SDKs, you **must provide a valid `User-Agent` header** with each request - Requests without proper authentication will return a `401 Unauthorized` error  ### Error Handling  The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a `statusCode` attribute indicating the outcome of your request.  ### Rate Limits  The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a `429 Too Many Requests` status code.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The language of message sent to the customer. If not provided the default customer language is used if available.
 * @export
 * @enum {string}
 */
const PaymentMessageLanguage = {
  EN: 'en',
  ES: 'es',
  CA: 'ca',
  PT: 'pt',
  DE: 'de',
  IT: 'it',
  FR: 'fr'
};

/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * The MONEI API is organized around REST principles. Our API is designed to be intuitive and developer-friendly.  ### Base URL  All API requests should be made to:  ``` https://api.monei.com/v1 ```  ### Environment  MONEI provides two environments:  - **Test Environment**: For development and testing without processing real payments - **Live Environment**: For processing real transactions in production  ### Client Libraries  We provide official SDKs to simplify integration:  - [PHP SDK](https://github.com/MONEI/monei-php-sdk) - [Python SDK](https://github.com/MONEI/monei-python-sdk) - [Node.js SDK](https://github.com/MONEI/monei-node-sdk) - [Postman Collection](https://postman.monei.com/)  Our SDKs handle authentication, error handling, and request formatting automatically.  You can download the OpenAPI specification from the https://js.monei.com/api/v1/openapi.json and generate your own client library using the [OpenAPI Generator](https://openapi-generator.tech/).  ### Important Requirements  - All API requests must be made over HTTPS - If you are not using our official SDKs, you **must provide a valid `User-Agent` header** with each request - Requests without proper authentication will return a `401 Unauthorized` error  ### Error Handling  The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a `statusCode` attribute indicating the outcome of your request.  ### Rate Limits  The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a `429 Too Many Requests` status code.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const PaymentNextActionTypeEnum = {
  CONFIRM: 'CONFIRM',
  CHALLENGE: 'CHALLENGE',
  FRICTIONLESS_CHALLENGE: 'FRICTIONLESS_CHALLENGE',
  BIZUM_CHALLENGE: 'BIZUM_CHALLENGE',
  COMPLETE: 'COMPLETE'
};

/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * The MONEI API is organized around REST principles. Our API is designed to be intuitive and developer-friendly.  ### Base URL  All API requests should be made to:  ``` https://api.monei.com/v1 ```  ### Environment  MONEI provides two environments:  - **Test Environment**: For development and testing without processing real payments - **Live Environment**: For processing real transactions in production  ### Client Libraries  We provide official SDKs to simplify integration:  - [PHP SDK](https://github.com/MONEI/monei-php-sdk) - [Python SDK](https://github.com/MONEI/monei-python-sdk) - [Node.js SDK](https://github.com/MONEI/monei-node-sdk) - [Postman Collection](https://postman.monei.com/)  Our SDKs handle authentication, error handling, and request formatting automatically.  You can download the OpenAPI specification from the https://js.monei.com/api/v1/openapi.json and generate your own client library using the [OpenAPI Generator](https://openapi-generator.tech/).  ### Important Requirements  - All API requests must be made over HTTPS - If you are not using our official SDKs, you **must provide a valid `User-Agent` header** with each request - Requests without proper authentication will return a `401 Unauthorized` error  ### Error Handling  The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a `statusCode` attribute indicating the outcome of your request.  ### Rate Limits  The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a `429 Too Many Requests` status code.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const PaymentPaymentMethodMethodEnum = {
  ALIPAY: 'alipay',
  CARD: 'card',
  BIZUM: 'bizum',
  PAYPAL: 'paypal',
  MBWAY: 'mbway',
  MULTIBANCO: 'multibanco',
  I_DEAL: 'iDeal',
  BANCONTACT: 'bancontact',
  SOFORT: 'sofort',
  TRUSTLY: 'trustly',
  SEPA: 'sepa',
  KLARNA: 'klarna',
  GIROPAY: 'giropay',
  EPS: 'eps',
  BLIK: 'blik'
};

/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * The MONEI API is organized around REST principles. Our API is designed to be intuitive and developer-friendly.  ### Base URL  All API requests should be made to:  ``` https://api.monei.com/v1 ```  ### Environment  MONEI provides two environments:  - **Test Environment**: For development and testing without processing real payments - **Live Environment**: For processing real transactions in production  ### Client Libraries  We provide official SDKs to simplify integration:  - [PHP SDK](https://github.com/MONEI/monei-php-sdk) - [Python SDK](https://github.com/MONEI/monei-python-sdk) - [Node.js SDK](https://github.com/MONEI/monei-node-sdk) - [Postman Collection](https://postman.monei.com/)  Our SDKs handle authentication, error handling, and request formatting automatically.  You can download the OpenAPI specification from the https://js.monei.com/api/v1/openapi.json and generate your own client library using the [OpenAPI Generator](https://openapi-generator.tech/).  ### Important Requirements  - All API requests must be made over HTTPS - If you are not using our official SDKs, you **must provide a valid `User-Agent` header** with each request - Requests without proper authentication will return a `401 Unauthorized` error  ### Error Handling  The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a `statusCode` attribute indicating the outcome of your request.  ### Rate Limits  The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a `429 Too Many Requests` status code.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const PaymentPaymentMethodCardBrandEnum = {
  VISA: 'visa',
  MASTERCARD: 'mastercard',
  DINERS: 'diners',
  AMEX: 'amex',
  JCB: 'jcb',
  UNIONPAY: 'unionpay',
  UNKNOWN: 'unknown'
};
const PaymentPaymentMethodCardTypeEnum = {
  DEBIT: 'debit',
  CREDIT: 'credit'
};
const PaymentPaymentMethodCardThreeDSecureFlowEnum = {
  CHALLENGE: 'CHALLENGE',
  FRICTIONLESS: 'FRICTIONLESS',
  FRICTIONLESS_CHALLENGE: 'FRICTIONLESS_CHALLENGE',
  DIRECT: 'DIRECT'
};
const PaymentPaymentMethodCardTokenizationMethodEnum = {
  APPLE_PAY: 'applePay',
  GOOGLE_PAY: 'googlePay',
  CLICK_TO_PAY: 'clickToPay'
};

/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * The MONEI API is organized around REST principles. Our API is designed to be intuitive and developer-friendly.  ### Base URL  All API requests should be made to:  ``` https://api.monei.com/v1 ```  ### Environment  MONEI provides two environments:  - **Test Environment**: For development and testing without processing real payments - **Live Environment**: For processing real transactions in production  ### Client Libraries  We provide official SDKs to simplify integration:  - [PHP SDK](https://github.com/MONEI/monei-php-sdk) - [Python SDK](https://github.com/MONEI/monei-python-sdk) - [Node.js SDK](https://github.com/MONEI/monei-node-sdk) - [Postman Collection](https://postman.monei.com/)  Our SDKs handle authentication, error handling, and request formatting automatically.  You can download the OpenAPI specification from the https://js.monei.com/api/v1/openapi.json and generate your own client library using the [OpenAPI Generator](https://openapi-generator.tech/).  ### Important Requirements  - All API requests must be made over HTTPS - If you are not using our official SDKs, you **must provide a valid `User-Agent` header** with each request - Requests without proper authentication will return a `401 Unauthorized` error  ### Error Handling  The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a `statusCode` attribute indicating the outcome of your request.  ### Rate Limits  The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a `429 Too Many Requests` status code.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const PaymentPaymentMethodKlarnaBillingCategoryEnum = {
  PAY_LATER: 'PAY_LATER',
  PAY_NOW: 'PAY_NOW',
  SLICE_IT: 'SLICE_IT',
  SLICE_IT_BY_CARD: 'SLICE_IT_BY_CARD'
};
const PaymentPaymentMethodKlarnaAuthPaymentMethodEnum = {
  INVOICE: 'invoice',
  FIXED_AMOUNT: 'fixed_amount',
  PIX: 'pix',
  BASE_ACCOUNT: 'base_account',
  DEFERRED_INTEREST: 'deferred_interest',
  DIRECT_DEBIT: 'direct_debit',
  DIRECT_BANK_TRANSFER: 'direct_bank_transfer',
  B2B_INVOICE: 'b2b_invoice',
  CARD: 'card',
  SLICE_IT_BY_CARD: 'slice_it_by_card'
};

/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * The MONEI API is organized around REST principles. Our API is designed to be intuitive and developer-friendly.  ### Base URL  All API requests should be made to:  ``` https://api.monei.com/v1 ```  ### Environment  MONEI provides two environments:  - **Test Environment**: For development and testing without processing real payments - **Live Environment**: For processing real transactions in production  ### Client Libraries  We provide official SDKs to simplify integration:  - [PHP SDK](https://github.com/MONEI/monei-php-sdk) - [Python SDK](https://github.com/MONEI/monei-python-sdk) - [Node.js SDK](https://github.com/MONEI/monei-node-sdk) - [Postman Collection](https://postman.monei.com/)  Our SDKs handle authentication, error handling, and request formatting automatically.  You can download the OpenAPI specification from the https://js.monei.com/api/v1/openapi.json and generate your own client library using the [OpenAPI Generator](https://openapi-generator.tech/).  ### Important Requirements  - All API requests must be made over HTTPS - If you are not using our official SDKs, you **must provide a valid `User-Agent` header** with each request - Requests without proper authentication will return a `401 Unauthorized` error  ### Error Handling  The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a `statusCode` attribute indicating the outcome of your request.  ### Rate Limits  The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a `429 Too Many Requests` status code.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The reason for refunding the Payment.
 * @export
 * @enum {string}
 */
const PaymentRefundReason = {
  DUPLICATED: 'duplicated',
  FRAUDULENT: 'fraudulent',
  REQUESTED_BY_CUSTOMER: 'requested_by_customer'
};

/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * The MONEI API is organized around REST principles. Our API is designed to be intuitive and developer-friendly.  ### Base URL  All API requests should be made to:  ``` https://api.monei.com/v1 ```  ### Environment  MONEI provides two environments:  - **Test Environment**: For development and testing without processing real payments - **Live Environment**: For processing real transactions in production  ### Client Libraries  We provide official SDKs to simplify integration:  - [PHP SDK](https://github.com/MONEI/monei-php-sdk) - [Python SDK](https://github.com/MONEI/monei-python-sdk) - [Node.js SDK](https://github.com/MONEI/monei-node-sdk) - [Postman Collection](https://postman.monei.com/)  Our SDKs handle authentication, error handling, and request formatting automatically.  You can download the OpenAPI specification from the https://js.monei.com/api/v1/openapi.json and generate your own client library using the [OpenAPI Generator](https://openapi-generator.tech/).  ### Important Requirements  - All API requests must be made over HTTPS - If you are not using our official SDKs, you **must provide a valid `User-Agent` header** with each request - Requests without proper authentication will return a `401 Unauthorized` error  ### Error Handling  The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a `statusCode` attribute indicating the outcome of your request.  ### Rate Limits  The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a `429 Too Many Requests` status code.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const PaymentSequenceTypeEnum = {
  RECURRING: 'recurring'
};

/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * The MONEI API is organized around REST principles. Our API is designed to be intuitive and developer-friendly.  ### Base URL  All API requests should be made to:  ``` https://api.monei.com/v1 ```  ### Environment  MONEI provides two environments:  - **Test Environment**: For development and testing without processing real payments - **Live Environment**: For processing real transactions in production  ### Client Libraries  We provide official SDKs to simplify integration:  - [PHP SDK](https://github.com/MONEI/monei-php-sdk) - [Python SDK](https://github.com/MONEI/monei-python-sdk) - [Node.js SDK](https://github.com/MONEI/monei-node-sdk) - [Postman Collection](https://postman.monei.com/)  Our SDKs handle authentication, error handling, and request formatting automatically.  You can download the OpenAPI specification from the https://js.monei.com/api/v1/openapi.json and generate your own client library using the [OpenAPI Generator](https://openapi-generator.tech/).  ### Important Requirements  - All API requests must be made over HTTPS - If you are not using our official SDKs, you **must provide a valid `User-Agent` header** with each request - Requests without proper authentication will return a `401 Unauthorized` error  ### Error Handling  The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a `statusCode` attribute indicating the outcome of your request.  ### Rate Limits  The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a `429 Too Many Requests` status code.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The status of the payment.
 * @export
 * @enum {string}
 */
const PaymentStatus = {
  SUCCEEDED: 'SUCCEEDED',
  PENDING: 'PENDING',
  FAILED: 'FAILED',
  CANCELED: 'CANCELED',
  REFUNDED: 'REFUNDED',
  PARTIALLY_REFUNDED: 'PARTIALLY_REFUNDED',
  AUTHORIZED: 'AUTHORIZED',
  EXPIRED: 'EXPIRED'
};

/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * The MONEI API is organized around REST principles. Our API is designed to be intuitive and developer-friendly.  ### Base URL  All API requests should be made to:  ``` https://api.monei.com/v1 ```  ### Environment  MONEI provides two environments:  - **Test Environment**: For development and testing without processing real payments - **Live Environment**: For processing real transactions in production  ### Client Libraries  We provide official SDKs to simplify integration:  - [PHP SDK](https://github.com/MONEI/monei-php-sdk) - [Python SDK](https://github.com/MONEI/monei-python-sdk) - [Node.js SDK](https://github.com/MONEI/monei-node-sdk) - [Postman Collection](https://postman.monei.com/)  Our SDKs handle authentication, error handling, and request formatting automatically.  You can download the OpenAPI specification from the https://js.monei.com/api/v1/openapi.json and generate your own client library using the [OpenAPI Generator](https://openapi-generator.tech/).  ### Important Requirements  - All API requests must be made over HTTPS - If you are not using our official SDKs, you **must provide a valid `User-Agent` header** with each request - Requests without proper authentication will return a `401 Unauthorized` error  ### Error Handling  The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a `statusCode` attribute indicating the outcome of your request.  ### Rate Limits  The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a `429 Too Many Requests` status code.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Controls when the funds will be captured.
 * @export
 * @enum {string}
 */
const PaymentTransactionType = {
  SALE: 'SALE',
  AUTH: 'AUTH',
  PAYOUT: 'PAYOUT',
  VERIF: 'VERIF'
};

/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * The MONEI API is organized around REST principles. Our API is designed to be intuitive and developer-friendly.  ### Base URL  All API requests should be made to:  ``` https://api.monei.com/v1 ```  ### Environment  MONEI provides two environments:  - **Test Environment**: For development and testing without processing real payments - **Live Environment**: For processing real transactions in production  ### Client Libraries  We provide official SDKs to simplify integration:  - [PHP SDK](https://github.com/MONEI/monei-php-sdk) - [Python SDK](https://github.com/MONEI/monei-python-sdk) - [Node.js SDK](https://github.com/MONEI/monei-node-sdk) - [Postman Collection](https://postman.monei.com/)  Our SDKs handle authentication, error handling, and request formatting automatically.  You can download the OpenAPI specification from the https://js.monei.com/api/v1/openapi.json and generate your own client library using the [OpenAPI Generator](https://openapi-generator.tech/).  ### Important Requirements  - All API requests must be made over HTTPS - If you are not using our official SDKs, you **must provide a valid `User-Agent` header** with each request - Requests without proper authentication will return a `401 Unauthorized` error  ### Error Handling  The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a `statusCode` attribute indicating the outcome of your request.  ### Rate Limits  The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a `429 Too Many Requests` status code.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const SendSubscriptionLinkRequestChannelEnum = {
  EMAIL: 'EMAIL',
  WHATSAPP: 'WHATSAPP',
  SMS: 'SMS'
};

/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * The MONEI API is organized around REST principles. Our API is designed to be intuitive and developer-friendly.  ### Base URL  All API requests should be made to:  ``` https://api.monei.com/v1 ```  ### Environment  MONEI provides two environments:  - **Test Environment**: For development and testing without processing real payments - **Live Environment**: For processing real transactions in production  ### Client Libraries  We provide official SDKs to simplify integration:  - [PHP SDK](https://github.com/MONEI/monei-php-sdk) - [Python SDK](https://github.com/MONEI/monei-python-sdk) - [Node.js SDK](https://github.com/MONEI/monei-node-sdk) - [Postman Collection](https://postman.monei.com/)  Our SDKs handle authentication, error handling, and request formatting automatically.  You can download the OpenAPI specification from the https://js.monei.com/api/v1/openapi.json and generate your own client library using the [OpenAPI Generator](https://openapi-generator.tech/).  ### Important Requirements  - All API requests must be made over HTTPS - If you are not using our official SDKs, you **must provide a valid `User-Agent` header** with each request - Requests without proper authentication will return a `401 Unauthorized` error  ### Error Handling  The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a `statusCode` attribute indicating the outcome of your request.  ### Rate Limits  The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a `429 Too Many Requests` status code.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const SendSubscriptionStatusRequestChannelEnum = {
  EMAIL: 'EMAIL',
  WHATSAPP: 'WHATSAPP',
  SMS: 'SMS'
};

/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * The MONEI API is organized around REST principles. Our API is designed to be intuitive and developer-friendly.  ### Base URL  All API requests should be made to:  ``` https://api.monei.com/v1 ```  ### Environment  MONEI provides two environments:  - **Test Environment**: For development and testing without processing real payments - **Live Environment**: For processing real transactions in production  ### Client Libraries  We provide official SDKs to simplify integration:  - [PHP SDK](https://github.com/MONEI/monei-php-sdk) - [Python SDK](https://github.com/MONEI/monei-python-sdk) - [Node.js SDK](https://github.com/MONEI/monei-node-sdk) - [Postman Collection](https://postman.monei.com/)  Our SDKs handle authentication, error handling, and request formatting automatically.  You can download the OpenAPI specification from the https://js.monei.com/api/v1/openapi.json and generate your own client library using the [OpenAPI Generator](https://openapi-generator.tech/).  ### Important Requirements  - All API requests must be made over HTTPS - If you are not using our official SDKs, you **must provide a valid `User-Agent` header** with each request - Requests without proper authentication will return a `401 Unauthorized` error  ### Error Handling  The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a `statusCode` attribute indicating the outcome of your request.  ### Rate Limits  The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a `429 Too Many Requests` status code.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Subscription interval.
 * @export
 * @enum {string}
 */
const SubscriptionInterval = {
  DAY: 'day',
  WEEK: 'week',
  MONTH: 'month',
  YEAR: 'year'
};

/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * The MONEI API is organized around REST principles. Our API is designed to be intuitive and developer-friendly.  ### Base URL  All API requests should be made to:  ``` https://api.monei.com/v1 ```  ### Environment  MONEI provides two environments:  - **Test Environment**: For development and testing without processing real payments - **Live Environment**: For processing real transactions in production  ### Client Libraries  We provide official SDKs to simplify integration:  - [PHP SDK](https://github.com/MONEI/monei-php-sdk) - [Python SDK](https://github.com/MONEI/monei-python-sdk) - [Node.js SDK](https://github.com/MONEI/monei-node-sdk) - [Postman Collection](https://postman.monei.com/)  Our SDKs handle authentication, error handling, and request formatting automatically.  You can download the OpenAPI specification from the https://js.monei.com/api/v1/openapi.json and generate your own client library using the [OpenAPI Generator](https://openapi-generator.tech/).  ### Important Requirements  - All API requests must be made over HTTPS - If you are not using our official SDKs, you **must provide a valid `User-Agent` header** with each request - Requests without proper authentication will return a `401 Unauthorized` error  ### Error Handling  The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a `statusCode` attribute indicating the outcome of your request.  ### Rate Limits  The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a `429 Too Many Requests` status code.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const SubscriptionPaymentMethodMethodEnum = {
  CARD: 'card'
};

/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * The MONEI API is organized around REST principles. Our API is designed to be intuitive and developer-friendly.  ### Base URL  All API requests should be made to:  ``` https://api.monei.com/v1 ```  ### Environment  MONEI provides two environments:  - **Test Environment**: For development and testing without processing real payments - **Live Environment**: For processing real transactions in production  ### Client Libraries  We provide official SDKs to simplify integration:  - [PHP SDK](https://github.com/MONEI/monei-php-sdk) - [Python SDK](https://github.com/MONEI/monei-python-sdk) - [Node.js SDK](https://github.com/MONEI/monei-node-sdk) - [Postman Collection](https://postman.monei.com/)  Our SDKs handle authentication, error handling, and request formatting automatically.  You can download the OpenAPI specification from the https://js.monei.com/api/v1/openapi.json and generate your own client library using the [OpenAPI Generator](https://openapi-generator.tech/).  ### Important Requirements  - All API requests must be made over HTTPS - If you are not using our official SDKs, you **must provide a valid `User-Agent` header** with each request - Requests without proper authentication will return a `401 Unauthorized` error  ### Error Handling  The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a `statusCode` attribute indicating the outcome of your request.  ### Rate Limits  The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a `429 Too Many Requests` status code.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const SubscriptionPaymentMethodCardBrandEnum = {
  VISA: 'visa',
  MASTERCARD: 'mastercard',
  DINERS: 'diners',
  AMEX: 'amex',
  JCB: 'jcb',
  UNIONPAY: 'unionpay',
  UNKNOWN: 'unknown'
};
const SubscriptionPaymentMethodCardTypeEnum = {
  DEBIT: 'debit',
  CREDIT: 'credit'
};

/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * The MONEI API is organized around REST principles. Our API is designed to be intuitive and developer-friendly.  ### Base URL  All API requests should be made to:  ``` https://api.monei.com/v1 ```  ### Environment  MONEI provides two environments:  - **Test Environment**: For development and testing without processing real payments - **Live Environment**: For processing real transactions in production  ### Client Libraries  We provide official SDKs to simplify integration:  - [PHP SDK](https://github.com/MONEI/monei-php-sdk) - [Python SDK](https://github.com/MONEI/monei-python-sdk) - [Node.js SDK](https://github.com/MONEI/monei-node-sdk) - [Postman Collection](https://postman.monei.com/)  Our SDKs handle authentication, error handling, and request formatting automatically.  You can download the OpenAPI specification from the https://js.monei.com/api/v1/openapi.json and generate your own client library using the [OpenAPI Generator](https://openapi-generator.tech/).  ### Important Requirements  - All API requests must be made over HTTPS - If you are not using our official SDKs, you **must provide a valid `User-Agent` header** with each request - Requests without proper authentication will return a `401 Unauthorized` error  ### Error Handling  The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a `statusCode` attribute indicating the outcome of your request.  ### Rate Limits  The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a `429 Too Many Requests` status code.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const SubscriptionRetryScheduleInnerIntervalEnum = {
  DAY: 'day',
  WEEK: 'week',
  MONTH: 'month',
  YEAR: 'year'
};

/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * The MONEI API is organized around REST principles. Our API is designed to be intuitive and developer-friendly.  ### Base URL  All API requests should be made to:  ``` https://api.monei.com/v1 ```  ### Environment  MONEI provides two environments:  - **Test Environment**: For development and testing without processing real payments - **Live Environment**: For processing real transactions in production  ### Client Libraries  We provide official SDKs to simplify integration:  - [PHP SDK](https://github.com/MONEI/monei-php-sdk) - [Python SDK](https://github.com/MONEI/monei-python-sdk) - [Node.js SDK](https://github.com/MONEI/monei-node-sdk) - [Postman Collection](https://postman.monei.com/)  Our SDKs handle authentication, error handling, and request formatting automatically.  You can download the OpenAPI specification from the https://js.monei.com/api/v1/openapi.json and generate your own client library using the [OpenAPI Generator](https://openapi-generator.tech/).  ### Important Requirements  - All API requests must be made over HTTPS - If you are not using our official SDKs, you **must provide a valid `User-Agent` header** with each request - Requests without proper authentication will return a `401 Unauthorized` error  ### Error Handling  The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a `statusCode` attribute indicating the outcome of your request.  ### Rate Limits  The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a `429 Too Many Requests` status code.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The status of the subscription.
 * @export
 * @enum {string}
 */
const SubscriptionStatus = {
  PENDING: 'PENDING',
  EXPIRED: 'EXPIRED',
  TRIALING: 'TRIALING',
  ACTIVE: 'ACTIVE',
  PAST_DUE: 'PAST_DUE',
  PAUSED: 'PAUSED',
  CANCELED: 'CANCELED'
};

const _excluded = ["accountId", "userAgent"];
const DEFAULT_USER_AGENT = `MONEI/Node/${pkg.version}`;
/**
 * Exception class for handling MONEI API errors
 * Contains detailed information about the error including status, statusCode,
 * requestId, and requestTime for debugging and logging purposes
 */
class ApiException extends Error {
  /**
   * Creates a new ApiException instance
   * @param res - The API exception response from the MONEI API
   */
  constructor(res) {
    super(res.message);
    this.status = void 0;
    this.statusCode = void 0;
    this.requestId = void 0;
    this.requestTime = void 0;
    this.status = res.status;
    this.statusCode = res.statusCode;
    this.requestId = res.requestId;
    this.requestTime = new Date(res.requestTime);
  }
}
/**
 * Extracts and returns the data from an Axios response
 * @param res - The Axios response object
 * @returns The data contained in the response
 */
const responseHandler = res => res.data;
/**
 * Handles errors from API requests
 * Transforms API errors into ApiException instances or rethrows other errors
 * @param error - The error object from a failed request
 * @throws {ApiException} When the error contains response data from the API
 * @throws {Error} When the error is of another type
 */
const errorHandler = error => {
  var _error$response;
  if (error != null && (_error$response = error.response) != null && _error$response.data) {
    throw new ApiException(error.response.data);
  }
  throw error instanceof Error ? error : new Error('Something went wrong');
};
/**
 * Main MONEI SDK client class
 * Provides access to MONEI's payment processing APIs including payments,
 * payment methods, subscriptions, and Apple Pay domain verification
 */
class Monei {
  /**
   * Creates a new MONEI SDK client instance
   * @param apiKey - Your MONEI API key
   * @param options - Additional configuration options including accountId for acting on behalf of merchants,
   *                  userAgent for identifying your application, and any Axios request configuration
   */
  constructor(apiKey, options) {
    this.apiKey = void 0;
    this.accountId = void 0;
    this.userAgent = void 0;
    /** Axios HTTP client instance used for API requests */
    this.client = void 0;
    /** API for managing payments */
    this.payments = void 0;
    /** API for managing payment methods */
    this.paymentMethods = void 0;
    /** API for managing subscriptions */
    this.subscriptions = void 0;
    /** API for Apple Pay domain verification */
    this.applePayDomain = void 0;
    /** API for managing Bizum */
    this.bizum = void 0;
    const _ref = options || {},
      {
        accountId,
        userAgent
      } = _ref,
      baseOptions = _objectWithoutPropertiesLoose(_ref, _excluded);
    this.apiKey = apiKey;
    this.accountId = accountId;
    this.userAgent = userAgent || DEFAULT_USER_AGENT;
    // Initialize the client
    this.client = globalAxios.create(baseOptions);
    // Add response interceptor
    this.client.interceptors.response.use(responseHandler, errorHandler);
    // Add request interceptor for user agent validation
    this.client.interceptors.request.use(config => {
      // If accountId is being used, validate that a custom userAgent is set
      if (this.accountId && this.userAgent === DEFAULT_USER_AGENT) {
        throw new Error('User-Agent must be provided when using Account ID');
      }
      return config;
    });
    // Set headers
    this.client.defaults.headers.common['User-Agent'] = this.userAgent;
    if (this.accountId) {
      this.client.defaults.headers.common['MONEI-Account-ID'] = this.accountId;
    }
    // Initialize API instances with the same client and config
    const config = new Configuration({
      apiKey: this.apiKey,
      baseOptions: {}
    });
    this.payments = new PaymentsApi(config, BASE_PATH, this.client);
    this.paymentMethods = new PaymentMethodsApi(config, BASE_PATH, this.client);
    this.subscriptions = new SubscriptionsApi(config, BASE_PATH, this.client);
    this.applePayDomain = new ApplePayDomainApi(config, BASE_PATH, this.client);
    this.bizum = new BizumApi(config, BASE_PATH, this.client);
  }
  /**
   * Set the account ID to act on behalf of a merchant
   * @param accountId - The merchant's account ID
   * @throws {Error} When trying to set an account ID with the default User-Agent
   */
  setAccountId(accountId) {
    // If setting accountId and using default User-Agent
    if (accountId && this.userAgent === DEFAULT_USER_AGENT) {
      throw new Error('User-Agent must be set before using Account ID');
    }
    this.accountId = accountId;
    // Update headers in client
    if (accountId) {
      this.client.defaults.headers.common['MONEI-Account-ID'] = accountId;
    } else {
      delete this.client.defaults.headers.common['MONEI-Account-ID'];
    }
  }
  /**
   * Set a custom User-Agent header
   * @param userAgent - Custom User-Agent string to identify your application
   */
  setUserAgent(userAgent) {
    this.userAgent = userAgent;
    // Update headers in client
    this.client.defaults.headers.common['User-Agent'] = userAgent;
  }
  /**
   * Verify webhook signature to ensure the webhook was sent by MONEI
   * @param body - Raw request body as string
   * @param signature - Signature from the MONEI-Signature header
   * @returns boolean indicating if the signature is valid
   */
  verifySignature(body, signature) {
    try {
      const parts = signature.split(',').reduce((result, part) => {
        const [key, value] = part.split('=');
        result[key] = value;
        return result;
      }, {});
      if (!parts.t || !parts.v1) {
        return false;
      }
      const hmac = crypto.createHmac('SHA256', this.apiKey).update(`${parts.t}.${body}`).digest('hex');
      return hmac === parts.v1;
    } catch (error) {
      return false;
    }
  }
}

export { ApiException, ApplePayDomainApi, ApplePayDomainApiAxiosParamCreator, ApplePayDomainApiFactory, ApplePayDomainApiFp, BizumApi, BizumApiAxiosParamCreator, BizumApiFactory, BizumApiFp, Configuration, Monei, PaymentCancellationReason, PaymentLastRefundReason, PaymentMessageChannel, PaymentMessageLanguage, PaymentMethodsApi, PaymentMethodsApiAxiosParamCreator, PaymentMethodsApiFactory, PaymentMethodsApiFp, PaymentNextActionTypeEnum, PaymentPaymentMethodCardBrandEnum, PaymentPaymentMethodCardThreeDSecureFlowEnum, PaymentPaymentMethodCardTokenizationMethodEnum, PaymentPaymentMethodCardTypeEnum, PaymentPaymentMethodKlarnaAuthPaymentMethodEnum, PaymentPaymentMethodKlarnaBillingCategoryEnum, PaymentPaymentMethodMethodEnum, PaymentRefundReason, PaymentSequenceTypeEnum, PaymentStatus, PaymentTransactionType, PaymentsApi, PaymentsApiAxiosParamCreator, PaymentsApiFactory, PaymentsApiFp, SendSubscriptionLinkRequestChannelEnum, SendSubscriptionStatusRequestChannelEnum, SubscriptionInterval, SubscriptionPaymentMethodCardBrandEnum, SubscriptionPaymentMethodCardTypeEnum, SubscriptionPaymentMethodMethodEnum, SubscriptionRetryScheduleInnerIntervalEnum, SubscriptionStatus, SubscriptionsApi, SubscriptionsApiAxiosParamCreator, SubscriptionsApiFactory, SubscriptionsApiFp };
//# sourceMappingURL=index.module.js.map
